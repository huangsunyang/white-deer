
// Generated from GLSLParser.g4 by ANTLR 4.12.0


#include "GLSLParserListener.h"

#include "GLSLParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct GLSLParserStaticData final {
  GLSLParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  GLSLParserStaticData(const GLSLParserStaticData&) = delete;
  GLSLParserStaticData(GLSLParserStaticData&&) = delete;
  GLSLParserStaticData& operator=(const GLSLParserStaticData&) = delete;
  GLSLParserStaticData& operator=(GLSLParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag glslparserParserOnceFlag;
GLSLParserStaticData *glslparserParserStaticData = nullptr;

void glslparserParserInitialize() {
  assert(glslparserParserStaticData == nullptr);
  auto staticData = std::make_unique<GLSLParserStaticData>(
    std::vector<std::string>{
      "translation_unit", "variable_identifier", "primary_expression", "postfix_expression", 
      "field_selection", "integer_expression", "function_call", "function_identifier", 
      "function_call_parameters", "unary_expression", "unary_operator", 
      "assignment_expression", "assignment_operator", "binary_expression", 
      "expression", "constant_expression", "declaration", "identifier_list", 
      "function_prototype", "function_parameters", "parameter_declarator", 
      "parameter_declaration", "parameter_type_specifier", "init_declarator_list", 
      "single_declaration", "typeless_declaration", "fully_specified_type", 
      "invariant_qualifier", "interpolation_qualifier", "layout_qualifier", 
      "layout_qualifier_id_list", "layout_qualifier_id", "precise_qualifier", 
      "type_qualifier", "single_type_qualifier", "storage_qualifier", "type_name_list", 
      "type_name", "type_specifier", "array_specifier", "dimension", "type_specifier_nonarray", 
      "precision_qualifier", "struct_specifier", "struct_declaration_list", 
      "struct_declaration", "struct_declarator_list", "struct_declarator", 
      "initializer", "initializer_list", "declaration_statement", "statement", 
      "simple_statement", "compound_statement", "statement_no_new_scope", 
      "compound_statement_no_new_scope", "statement_list", "expression_statement", 
      "selection_statement", "selection_rest_statement", "condition", "switch_statement", 
      "case_label", "iteration_statement", "for_init_statement", "for_rest_statement", 
      "jump_statement", "external_declaration", "function_definition"
    },
    std::vector<std::string>{
      "", "'atomic_uint'", "'attribute'", "'bool'", "'break'", "'buffer'", 
      "'bvec2'", "'bvec3'", "'bvec4'", "'case'", "'centroid'", "'coherent'", 
      "'const'", "'continue'", "'default'", "'discard'", "'dmat2'", "'dmat2x2'", 
      "'dmat2x3'", "'dmat2x4'", "'dmat3'", "'dmat3x2'", "'dmat3x3'", "'dmat3x4'", 
      "'dmat4'", "'dmat4x2'", "'dmat4x3'", "'dmat4x4'", "'do'", "'double'", 
      "'dvec2'", "'dvec3'", "'dvec4'", "'else'", "'false'", "'flat'", "'float'", 
      "'for'", "'highp'", "'if'", "'iimage1D'", "'iimage1DArray'", "'iimage2D'", 
      "'iimage2DArray'", "'iimage2DMS'", "'iimage2DMSArray'", "'iimage2DRect'", 
      "'iimage3D'", "'iimageBuffer'", "'iimageCube'", "'iimageCubeArray'", 
      "'image1D'", "'image1DArray'", "'image2D'", "'image2DArray'", "'image2DMS'", 
      "'image2DMSArray'", "'image2DRect'", "'image3D'", "'imageBuffer'", 
      "'imageCube'", "'imageCubeArray'", "'in'", "'inout'", "'int'", "'invariant'", 
      "'isampler1D'", "'isampler1DArray'", "'isampler2D'", "'isampler2DArray'", 
      "'isampler2DMS'", "'isampler2DMSArray'", "'isampler2DRect'", "'isampler3D'", 
      "'isamplerBuffer'", "'isamplerCube'", "'isamplerCubeArray'", "'isubpassInput'", 
      "'isubpassInputMS'", "'itexture1D'", "'itexture1DArray'", "'itexture2D'", 
      "'itexture2DArray'", "'itexture2DMS'", "'itexture2DMSArray'", "'itexture2DRect'", 
      "'itexture3D'", "'itextureBuffer'", "'itextureCube'", "'itextureCubeArray'", 
      "'ivec2'", "'ivec3'", "'ivec4'", "'layout'", "'lowp'", "'mat2'", "'mat2x2'", 
      "'mat2x3'", "'mat2x4'", "'mat3'", "'mat3x2'", "'mat3x3'", "'mat3x4'", 
      "'mat4'", "'mat4x2'", "'mat4x3'", "'mat4x4'", "'mediump'", "'noperspective'", 
      "'out'", "'patch'", "'precise'", "'precision'", "'readonly'", "'restrict'", 
      "'return'", "'sample'", "'sampler'", "'sampler1D'", "'sampler1DArray'", 
      "'sampler1DArrayShadow'", "'sampler1DShadow'", "'sampler2D'", "'sampler2DArray'", 
      "'sampler2DArrayShadow'", "'sampler2DMS'", "'sampler2DMSArray'", "'sampler2DRect'", 
      "'sampler2DRectShadow'", "'sampler2DShadow'", "'sampler3D'", "'samplerBuffer'", 
      "'samplerCube'", "'samplerCubeArray'", "'samplerCubeArrayShadow'", 
      "'samplerCubeShadow'", "'samplerShadow'", "'shared'", "'smooth'", 
      "'struct'", "'subpassInput'", "'subpassInputMS'", "'subroutine'", 
      "'switch'", "'texture1D'", "'texture1DArray'", "'texture2D'", "'texture2DArray'", 
      "'texture2DMS'", "'texture2DMSArray'", "'texture2DRect'", "'texture3D'", 
      "'textureBuffer'", "'textureCube'", "'textureCubeArray'", "'true'", 
      "'uimage1D'", "'uimage1DArray'", "'uimage2D'", "'uimage2DArray'", 
      "'uimage2DMS'", "'uimage2DMSArray'", "'uimage2DRect'", "'uimage3D'", 
      "'uimageBuffer'", "'uimageCube'", "'uimageCubeArray'", "'uint'", "'uniform'", 
      "'usampler1D'", "'usampler1DArray'", "'usampler2D'", "'usampler2DArray'", 
      "'usampler2DMS'", "'usampler2DMSArray'", "'usampler2DRect'", "'usampler3D'", 
      "'usamplerBuffer'", "'usamplerCube'", "'usamplerCubeArray'", "'usubpassInput'", 
      "'usubpassInputMS'", "'utexture1D'", "'utexture1DArray'", "'utexture2D'", 
      "'utexture2DArray'", "'utexture2DMS'", "'utexture2DMSArray'", "'utexture2DRect'", 
      "'utexture3D'", "'utextureBuffer'", "'utextureCube'", "'utextureCubeArray'", 
      "'uvec2'", "'uvec3'", "'uvec4'", "'varying'", "'vec2'", "'vec3'", 
      "'vec4'", "'void'", "'volatile'", "'while'", "'writeonly'", "'+='", 
      "'&'", "'&='", "'&&'", "'!'", "'^'", "':'", "','", "'-'", "'--'", 
      "'/='", "'.'", "'=='", "'='", "'>='", "'++'", "'<='", "'<'", "'<<='", 
      "'{'", "'['", "'<<'", "'('", "'%='", "'*='", "'!='", "", "'|='", "'||'", 
      "'%'", "'+'", "'\\u003F'", "'>'", "'>>='", "'}'", "']'", "'>>'", "')'", 
      "';'", "'/'", "'*'", "'-='", "'~'", "'|'", "'^='", "'^^'", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "'debug'", "", "'off'", "'on'", "'optimize'", 
      "", "'STDGL'"
    },
    std::vector<std::string>{
      "", "ATOMIC_UINT", "ATTRIBUTE", "BOOL", "BREAK", "BUFFER", "BVEC2", 
      "BVEC3", "BVEC4", "CASE", "CENTROID", "COHERENT", "CONST", "CONTINUE", 
      "DEFAULT", "DISCARD", "DMAT2", "DMAT2X2", "DMAT2X3", "DMAT2X4", "DMAT3", 
      "DMAT3X2", "DMAT3X3", "DMAT3X4", "DMAT4", "DMAT4X2", "DMAT4X3", "DMAT4X4", 
      "DO", "DOUBLE", "DVEC2", "DVEC3", "DVEC4", "ELSE", "FALSE", "FLAT", 
      "FLOAT", "FOR", "HIGHP", "IF", "IIMAGE1D", "IIMAGE1DARRAY", "IIMAGE2D", 
      "IIMAGE2DARRAY", "IIMAGE2DMS", "IIMAGE2DMSARRAY", "IIMAGE2DRECT", 
      "IIMAGE3D", "IIMAGEBUFFER", "IIMAGECUBE", "IIMAGECUBEARRAY", "IMAGE1D", 
      "IMAGE1DARRAY", "IMAGE2D", "IMAGE2DARRAY", "IMAGE2DMS", "IMAGE2DMSARRAY", 
      "IMAGE2DRECT", "IMAGE3D", "IMAGEBUFFER", "IMAGECUBE", "IMAGECUBEARRAY", 
      "IN", "INOUT", "INT", "INVARIANT", "ISAMPLER1D", "ISAMPLER1DARRAY", 
      "ISAMPLER2D", "ISAMPLER2DARRAY", "ISAMPLER2DMS", "ISAMPLER2DMSARRAY", 
      "ISAMPLER2DRECT", "ISAMPLER3D", "ISAMPLERBUFFER", "ISAMPLERCUBE", 
      "ISAMPLERCUBEARRAY", "ISUBPASSINPUT", "ISUBPASSINPUTMS", "ITEXTURE1D", 
      "ITEXTURE1DARRAY", "ITEXTURE2D", "ITEXTURE2DARRAY", "ITEXTURE2DMS", 
      "ITEXTURE2DMSARRAY", "ITEXTURE2DRECT", "ITEXTURE3D", "ITEXTUREBUFFER", 
      "ITEXTURECUBE", "ITEXTURECUBEARRAY", "IVEC2", "IVEC3", "IVEC4", "LAYOUT", 
      "LOWP", "MAT2", "MAT2X2", "MAT2X3", "MAT2X4", "MAT3", "MAT3X2", "MAT3X3", 
      "MAT3X4", "MAT4", "MAT4X2", "MAT4X3", "MAT4X4", "MEDIUMP", "NOPERSPECTIVE", 
      "OUT", "PATCH", "PRECISE", "PRECISION", "READONLY", "RESTRICT", "RETURN", 
      "SAMPLE", "SAMPLER", "SAMPLER1D", "SAMPLER1DARRAY", "SAMPLER1DARRAYSHADOW", 
      "SAMPLER1DSHADOW", "SAMPLER2D", "SAMPLER2DARRAY", "SAMPLER2DARRAYSHADOW", 
      "SAMPLER2DMS", "SAMPLER2DMSARRAY", "SAMPLER2DRECT", "SAMPLER2DRECTSHADOW", 
      "SAMPLER2DSHADOW", "SAMPLER3D", "SAMPLERBUFFER", "SAMPLERCUBE", "SAMPLERCUBEARRAY", 
      "SAMPLERCUBEARRAYSHADOW", "SAMPLERCUBESHADOW", "SAMPLERSHADOW", "SHARED", 
      "SMOOTH", "STRUCT", "SUBPASSINPUT", "SUBPASSINPUTMS", "SUBROUTINE", 
      "SWITCH", "TEXTURE1D", "TEXTURE1DARRAY", "TEXTURE2D", "TEXTURE2DARRAY", 
      "TEXTURE2DMS", "TEXTURE2DMSARRAY", "TEXTURE2DRECT", "TEXTURE3D", "TEXTUREBUFFER", 
      "TEXTURECUBE", "TEXTURECUBEARRAY", "TRUE", "UIMAGE1D", "UIMAGE1DARRAY", 
      "UIMAGE2D", "UIMAGE2DARRAY", "UIMAGE2DMS", "UIMAGE2DMSARRAY", "UIMAGE2DRECT", 
      "UIMAGE3D", "UIMAGEBUFFER", "UIMAGECUBE", "UIMAGECUBEARRAY", "UINT", 
      "UNIFORM", "USAMPLER1D", "USAMPLER1DARRAY", "USAMPLER2D", "USAMPLER2DARRAY", 
      "USAMPLER2DMS", "USAMPLER2DMSARRAY", "USAMPLER2DRECT", "USAMPLER3D", 
      "USAMPLERBUFFER", "USAMPLERCUBE", "USAMPLERCUBEARRAY", "USUBPASSINPUT", 
      "USUBPASSINPUTMS", "UTEXTURE1D", "UTEXTURE1DARRAY", "UTEXTURE2D", 
      "UTEXTURE2DARRAY", "UTEXTURE2DMS", "UTEXTURE2DMSARRAY", "UTEXTURE2DRECT", 
      "UTEXTURE3D", "UTEXTUREBUFFER", "UTEXTURECUBE", "UTEXTURECUBEARRAY", 
      "UVEC2", "UVEC3", "UVEC4", "VARYING", "VEC2", "VEC3", "VEC4", "VOID", 
      "VOLATILE", "WHILE", "WRITEONLY", "ADD_ASSIGN", "AMPERSAND", "AND_ASSIGN", 
      "AND_OP", "BANG", "CARET", "COLON", "COMMA", "DASH", "DEC_OP", "DIV_ASSIGN", 
      "DOT", "EQ_OP", "EQUAL", "GE_OP", "INC_OP", "LE_OP", "LEFT_ANGLE", 
      "LEFT_ASSIGN", "LEFT_BRACE", "LEFT_BRACKET", "LEFT_OP", "LEFT_PAREN", 
      "MOD_ASSIGN", "MUL_ASSIGN", "NE_OP", "NUMBER_SIGN", "OR_ASSIGN", "OR_OP", 
      "PERCENT", "PLUS", "QUESTION", "RIGHT_ANGLE", "RIGHT_ASSIGN", "RIGHT_BRACE", 
      "RIGHT_BRACKET", "RIGHT_OP", "RIGHT_PAREN", "SEMICOLON", "SLASH", 
      "STAR", "SUB_ASSIGN", "TILDE", "VERTICAL_BAR", "XOR_ASSIGN", "XOR_OP", 
      "DOUBLECONSTANT", "FLOATCONSTANT", "INTCONSTANT", "UINTCONSTANT", 
      "BLOCK_COMMENT", "LINE_COMMENT", "LINE_CONTINUATION", "IDENTIFIER", 
      "WHITE_SPACE", "DEFINE_DIRECTIVE", "ELIF_DIRECTIVE", "ELSE_DIRECTIVE", 
      "ENDIF_DIRECTIVE", "ERROR_DIRECTIVE", "EXTENSION_DIRECTIVE", "IF_DIRECTIVE", 
      "IFDEF_DIRECTIVE", "IFNDEF_DIRECTIVE", "LINE_DIRECTIVE", "PRAGMA_DIRECTIVE", 
      "UNDEF_DIRECTIVE", "VERSION_DIRECTIVE", "SPACE_TAB_0", "NEWLINE_0", 
      "MACRO_NAME", "NEWLINE_1", "SPACE_TAB_1", "CONSTANT_EXPRESSION", "NEWLINE_2", 
      "ERROR_MESSAGE", "NEWLINE_3", "BEHAVIOR", "EXTENSION_NAME", "NEWLINE_4", 
      "SPACE_TAB_2", "NEWLINE_5", "MACRO_IDENTIFIER", "NEWLINE_6", "SPACE_TAB_3", 
      "LINE_EXPRESSION", "NEWLINE_7", "MACRO_ESC_NEWLINE", "MACRO_TEXT", 
      "NEWLINE_8", "DEBUG", "NEWLINE_9", "OFF", "ON", "OPTIMIZE", "SPACE_TAB_5", 
      "STDGL", "PROGRAM_TEXT", "NEWLINE_10", "SPACE_TAB_6", "NEWLINE_11", 
      "NUMBER", "PROFILE", "SPACE_TAB_7"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,307,808,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,
  	56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,
  	63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,1,0,5,0,140,8,0,
  	10,0,12,0,143,9,0,1,0,1,0,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
  	1,2,1,2,3,2,160,8,2,1,3,1,3,1,3,1,3,1,3,3,3,167,8,3,1,3,1,3,3,3,171,8,
  	3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,3,3,181,8,3,1,3,1,3,1,3,1,3,1,3,1,3,
  	1,3,1,3,5,3,191,8,3,10,3,12,3,194,9,3,1,4,1,4,3,4,198,8,4,1,5,1,5,1,6,
  	1,6,1,6,3,6,205,8,6,1,6,1,6,1,7,1,7,3,7,211,8,7,1,8,1,8,1,8,5,8,216,8,
  	8,10,8,12,8,219,9,8,1,8,3,8,222,8,8,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,3,
  	9,232,8,9,1,10,1,10,1,11,1,11,1,11,1,11,1,11,3,11,241,8,11,1,12,1,12,
  	1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,
  	1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,
  	1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,5,13,281,8,13,10,13,12,13,284,
  	9,13,1,14,1,14,1,14,1,14,1,14,1,14,5,14,292,8,14,10,14,12,14,295,9,14,
  	1,15,1,15,1,15,1,15,1,15,1,15,1,15,3,15,304,8,15,1,16,1,16,1,16,1,16,
  	1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,
  	3,16,324,8,16,3,16,326,8,16,1,16,1,16,1,16,1,16,3,16,332,8,16,1,16,1,
  	16,3,16,336,8,16,1,17,1,17,1,17,5,17,341,8,17,10,17,12,17,344,9,17,1,
  	18,1,18,1,18,1,18,3,18,350,8,18,1,18,1,18,1,19,1,19,1,19,5,19,357,8,19,
  	10,19,12,19,360,9,19,1,20,1,20,1,20,3,20,365,8,20,1,21,1,21,1,21,3,21,
  	370,8,21,1,21,1,21,3,21,374,8,21,1,22,1,22,1,23,1,23,1,23,5,23,381,8,
  	23,10,23,12,23,384,9,23,1,24,1,24,3,24,388,8,24,1,25,1,25,3,25,392,8,
  	25,1,25,1,25,3,25,396,8,25,1,26,1,26,1,26,1,26,3,26,402,8,26,1,27,1,27,
  	1,28,1,28,1,29,1,29,1,29,1,29,1,29,1,30,1,30,1,30,5,30,416,8,30,10,30,
  	12,30,419,9,30,1,31,1,31,1,31,3,31,424,8,31,1,31,3,31,427,8,31,1,32,1,
  	32,1,33,4,33,432,8,33,11,33,12,33,433,1,34,1,34,1,34,1,34,1,34,1,34,3,
  	34,442,8,34,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,
  	35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,3,35,464,8,35,1,35,1,35,3,
  	35,468,8,35,1,36,1,36,1,36,5,36,473,8,36,10,36,12,36,476,9,36,1,37,1,
  	37,1,38,1,38,3,38,482,8,38,1,39,4,39,485,8,39,11,39,12,39,486,1,40,1,
  	40,3,40,491,8,40,1,40,1,40,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,
  	41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,
  	41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,
  	41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,
  	41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,
  	41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,
  	41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,
  	41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,
  	41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,
  	41,3,41,616,8,41,1,42,1,42,1,43,1,43,3,43,622,8,43,1,43,1,43,1,43,1,43,
  	1,44,4,44,629,8,44,11,44,12,44,630,1,45,1,45,1,45,1,45,1,45,1,45,1,45,
  	1,45,1,45,3,45,642,8,45,1,46,1,46,1,46,5,46,647,8,46,10,46,12,46,650,
  	9,46,1,47,1,47,3,47,654,8,47,1,48,1,48,1,48,1,48,3,48,660,8,48,1,48,1,
  	48,3,48,664,8,48,1,49,1,49,1,49,5,49,669,8,49,10,49,12,49,672,9,49,1,
  	50,1,50,1,51,1,51,3,51,678,8,51,1,52,1,52,1,52,1,52,1,52,1,52,1,52,3,
  	52,687,8,52,1,53,1,53,3,53,691,8,53,1,53,1,53,1,54,1,54,3,54,697,8,54,
  	1,55,1,55,3,55,701,8,55,1,55,1,55,1,56,4,56,706,8,56,11,56,12,56,707,
  	1,57,1,57,1,57,1,57,3,57,714,8,57,1,58,1,58,1,58,1,58,1,58,1,58,1,59,
  	1,59,1,59,3,59,725,8,59,1,60,1,60,1,60,1,60,1,60,1,60,3,60,733,8,60,1,
  	61,1,61,1,61,1,61,1,61,1,61,3,61,741,8,61,1,61,1,61,1,62,1,62,1,62,1,
  	62,1,62,1,62,3,62,751,8,62,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,
  	63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,3,63,774,
  	8,63,1,64,1,64,3,64,778,8,64,1,65,3,65,781,8,65,1,65,1,65,3,65,785,8,
  	65,1,66,1,66,1,66,1,66,1,66,1,66,3,66,793,8,66,1,66,1,66,1,66,3,66,798,
  	8,66,1,67,1,67,1,67,3,67,803,8,67,1,68,1,68,1,68,1,68,0,3,6,26,28,69,
  	0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,
  	50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,
  	96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,
  	132,134,136,0,9,4,0,208,208,212,212,234,234,246,246,10,0,204,204,206,
  	206,214,214,217,217,222,222,227,228,231,231,237,237,245,245,248,248,2,
  	0,233,233,243,244,2,0,212,212,234,234,2,0,225,225,240,240,3,0,218,218,
  	220,221,236,236,2,0,216,216,229,229,3,0,35,35,108,108,138,138,3,0,38,
  	38,94,94,107,107,981,0,141,1,0,0,0,2,146,1,0,0,0,4,159,1,0,0,0,6,170,
  	1,0,0,0,8,197,1,0,0,0,10,199,1,0,0,0,12,201,1,0,0,0,14,210,1,0,0,0,16,
  	221,1,0,0,0,18,231,1,0,0,0,20,233,1,0,0,0,22,240,1,0,0,0,24,242,1,0,0,
  	0,26,244,1,0,0,0,28,285,1,0,0,0,30,303,1,0,0,0,32,335,1,0,0,0,34,337,
  	1,0,0,0,36,345,1,0,0,0,38,353,1,0,0,0,40,361,1,0,0,0,42,373,1,0,0,0,44,
  	375,1,0,0,0,46,377,1,0,0,0,48,385,1,0,0,0,50,389,1,0,0,0,52,401,1,0,0,
  	0,54,403,1,0,0,0,56,405,1,0,0,0,58,407,1,0,0,0,60,412,1,0,0,0,62,426,
  	1,0,0,0,64,428,1,0,0,0,66,431,1,0,0,0,68,441,1,0,0,0,70,467,1,0,0,0,72,
  	469,1,0,0,0,74,477,1,0,0,0,76,479,1,0,0,0,78,484,1,0,0,0,80,488,1,0,0,
  	0,82,615,1,0,0,0,84,617,1,0,0,0,86,619,1,0,0,0,88,628,1,0,0,0,90,641,
  	1,0,0,0,92,643,1,0,0,0,94,651,1,0,0,0,96,663,1,0,0,0,98,665,1,0,0,0,100,
  	673,1,0,0,0,102,677,1,0,0,0,104,686,1,0,0,0,106,688,1,0,0,0,108,696,1,
  	0,0,0,110,698,1,0,0,0,112,705,1,0,0,0,114,713,1,0,0,0,116,715,1,0,0,0,
  	118,721,1,0,0,0,120,732,1,0,0,0,122,734,1,0,0,0,124,750,1,0,0,0,126,773,
  	1,0,0,0,128,777,1,0,0,0,130,780,1,0,0,0,132,797,1,0,0,0,134,802,1,0,0,
  	0,136,804,1,0,0,0,138,140,3,134,67,0,139,138,1,0,0,0,140,143,1,0,0,0,
  	141,139,1,0,0,0,141,142,1,0,0,0,142,144,1,0,0,0,143,141,1,0,0,0,144,145,
  	5,0,0,1,145,1,1,0,0,0,146,147,5,257,0,0,147,3,1,0,0,0,148,160,3,2,1,0,
  	149,160,5,155,0,0,150,160,5,34,0,0,151,160,5,252,0,0,152,160,5,253,0,
  	0,153,160,5,251,0,0,154,160,5,250,0,0,155,156,5,226,0,0,156,157,3,28,
  	14,0,157,158,5,241,0,0,158,160,1,0,0,0,159,148,1,0,0,0,159,149,1,0,0,
  	0,159,150,1,0,0,0,159,151,1,0,0,0,159,152,1,0,0,0,159,153,1,0,0,0,159,
  	154,1,0,0,0,159,155,1,0,0,0,160,5,1,0,0,0,161,162,6,3,-1,0,162,171,3,
  	4,2,0,163,164,3,76,38,0,164,166,5,226,0,0,165,167,3,16,8,0,166,165,1,
  	0,0,0,166,167,1,0,0,0,167,168,1,0,0,0,168,169,5,241,0,0,169,171,1,0,0,
  	0,170,161,1,0,0,0,170,163,1,0,0,0,171,192,1,0,0,0,172,173,10,6,0,0,173,
  	174,5,224,0,0,174,175,3,10,5,0,175,176,5,239,0,0,176,191,1,0,0,0,177,
  	178,10,5,0,0,178,180,5,226,0,0,179,181,3,16,8,0,180,179,1,0,0,0,180,181,
  	1,0,0,0,181,182,1,0,0,0,182,191,5,241,0,0,183,184,10,3,0,0,184,185,5,
  	215,0,0,185,191,3,8,4,0,186,187,10,2,0,0,187,191,5,219,0,0,188,189,10,
  	1,0,0,189,191,5,213,0,0,190,172,1,0,0,0,190,177,1,0,0,0,190,183,1,0,0,
  	0,190,186,1,0,0,0,190,188,1,0,0,0,191,194,1,0,0,0,192,190,1,0,0,0,192,
  	193,1,0,0,0,193,7,1,0,0,0,194,192,1,0,0,0,195,198,3,2,1,0,196,198,3,12,
  	6,0,197,195,1,0,0,0,197,196,1,0,0,0,198,9,1,0,0,0,199,200,3,28,14,0,200,
  	11,1,0,0,0,201,202,3,14,7,0,202,204,5,226,0,0,203,205,3,16,8,0,204,203,
  	1,0,0,0,204,205,1,0,0,0,205,206,1,0,0,0,206,207,5,241,0,0,207,13,1,0,
  	0,0,208,211,3,76,38,0,209,211,3,6,3,0,210,208,1,0,0,0,210,209,1,0,0,0,
  	211,15,1,0,0,0,212,217,3,22,11,0,213,214,5,211,0,0,214,216,3,22,11,0,
  	215,213,1,0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,222,
  	1,0,0,0,219,217,1,0,0,0,220,222,5,200,0,0,221,212,1,0,0,0,221,220,1,0,
  	0,0,222,17,1,0,0,0,223,232,3,6,3,0,224,225,5,219,0,0,225,232,3,18,9,0,
  	226,227,5,213,0,0,227,232,3,18,9,0,228,229,3,20,10,0,229,230,3,18,9,0,
  	230,232,1,0,0,0,231,223,1,0,0,0,231,224,1,0,0,0,231,226,1,0,0,0,231,228,
  	1,0,0,0,232,19,1,0,0,0,233,234,7,0,0,0,234,21,1,0,0,0,235,241,3,30,15,
  	0,236,237,3,18,9,0,237,238,3,24,12,0,238,239,3,22,11,0,239,241,1,0,0,
  	0,240,235,1,0,0,0,240,236,1,0,0,0,241,23,1,0,0,0,242,243,7,1,0,0,243,
  	25,1,0,0,0,244,245,6,13,-1,0,245,246,3,18,9,0,246,282,1,0,0,0,247,248,
  	10,11,0,0,248,249,7,2,0,0,249,281,3,26,13,12,250,251,10,10,0,0,251,252,
  	7,3,0,0,252,281,3,26,13,11,253,254,10,9,0,0,254,255,7,4,0,0,255,281,3,
  	26,13,10,256,257,10,8,0,0,257,258,7,5,0,0,258,281,3,26,13,9,259,260,10,
  	7,0,0,260,261,7,6,0,0,261,281,3,26,13,8,262,263,10,6,0,0,263,264,5,205,
  	0,0,264,281,3,26,13,7,265,266,10,5,0,0,266,267,5,209,0,0,267,281,3,26,
  	13,6,268,269,10,4,0,0,269,270,5,247,0,0,270,281,3,26,13,5,271,272,10,
  	3,0,0,272,273,5,207,0,0,273,281,3,26,13,4,274,275,10,2,0,0,275,276,5,
  	249,0,0,276,281,3,26,13,3,277,278,10,1,0,0,278,279,5,232,0,0,279,281,
  	3,26,13,2,280,247,1,0,0,0,280,250,1,0,0,0,280,253,1,0,0,0,280,256,1,0,
  	0,0,280,259,1,0,0,0,280,262,1,0,0,0,280,265,1,0,0,0,280,268,1,0,0,0,280,
  	271,1,0,0,0,280,274,1,0,0,0,280,277,1,0,0,0,281,284,1,0,0,0,282,280,1,
  	0,0,0,282,283,1,0,0,0,283,27,1,0,0,0,284,282,1,0,0,0,285,286,6,14,-1,
  	0,286,287,3,22,11,0,287,293,1,0,0,0,288,289,10,1,0,0,289,290,5,211,0,
  	0,290,292,3,22,11,0,291,288,1,0,0,0,292,295,1,0,0,0,293,291,1,0,0,0,293,
  	294,1,0,0,0,294,29,1,0,0,0,295,293,1,0,0,0,296,304,3,26,13,0,297,298,
  	3,26,13,0,298,299,5,235,0,0,299,300,3,28,14,0,300,301,5,210,0,0,301,302,
  	3,22,11,0,302,304,1,0,0,0,303,296,1,0,0,0,303,297,1,0,0,0,304,31,1,0,
  	0,0,305,306,3,36,18,0,306,307,5,242,0,0,307,336,1,0,0,0,308,309,3,46,
  	23,0,309,310,5,242,0,0,310,336,1,0,0,0,311,312,5,112,0,0,312,313,3,84,
  	42,0,313,314,3,76,38,0,314,315,5,242,0,0,315,336,1,0,0,0,316,317,3,66,
  	33,0,317,318,5,257,0,0,318,319,5,223,0,0,319,320,3,88,44,0,320,325,5,
  	238,0,0,321,323,5,257,0,0,322,324,3,78,39,0,323,322,1,0,0,0,323,324,1,
  	0,0,0,324,326,1,0,0,0,325,321,1,0,0,0,325,326,1,0,0,0,326,327,1,0,0,0,
  	327,328,5,242,0,0,328,336,1,0,0,0,329,331,3,66,33,0,330,332,3,34,17,0,
  	331,330,1,0,0,0,331,332,1,0,0,0,332,333,1,0,0,0,333,334,5,242,0,0,334,
  	336,1,0,0,0,335,305,1,0,0,0,335,308,1,0,0,0,335,311,1,0,0,0,335,316,1,
  	0,0,0,335,329,1,0,0,0,336,33,1,0,0,0,337,342,5,257,0,0,338,339,5,211,
  	0,0,339,341,5,257,0,0,340,338,1,0,0,0,341,344,1,0,0,0,342,340,1,0,0,0,
  	342,343,1,0,0,0,343,35,1,0,0,0,344,342,1,0,0,0,345,346,3,52,26,0,346,
  	347,5,257,0,0,347,349,5,226,0,0,348,350,3,38,19,0,349,348,1,0,0,0,349,
  	350,1,0,0,0,350,351,1,0,0,0,351,352,5,241,0,0,352,37,1,0,0,0,353,358,
  	3,42,21,0,354,355,5,211,0,0,355,357,3,42,21,0,356,354,1,0,0,0,357,360,
  	1,0,0,0,358,356,1,0,0,0,358,359,1,0,0,0,359,39,1,0,0,0,360,358,1,0,0,
  	0,361,362,3,76,38,0,362,364,5,257,0,0,363,365,3,78,39,0,364,363,1,0,0,
  	0,364,365,1,0,0,0,365,41,1,0,0,0,366,369,3,66,33,0,367,370,3,40,20,0,
  	368,370,3,44,22,0,369,367,1,0,0,0,369,368,1,0,0,0,370,374,1,0,0,0,371,
  	374,3,40,20,0,372,374,3,44,22,0,373,366,1,0,0,0,373,371,1,0,0,0,373,372,
  	1,0,0,0,374,43,1,0,0,0,375,376,3,76,38,0,376,45,1,0,0,0,377,382,3,48,
  	24,0,378,379,5,211,0,0,379,381,3,50,25,0,380,378,1,0,0,0,381,384,1,0,
  	0,0,382,380,1,0,0,0,382,383,1,0,0,0,383,47,1,0,0,0,384,382,1,0,0,0,385,
  	387,3,52,26,0,386,388,3,50,25,0,387,386,1,0,0,0,387,388,1,0,0,0,388,49,
  	1,0,0,0,389,391,5,257,0,0,390,392,3,78,39,0,391,390,1,0,0,0,391,392,1,
  	0,0,0,392,395,1,0,0,0,393,394,5,217,0,0,394,396,3,96,48,0,395,393,1,0,
  	0,0,395,396,1,0,0,0,396,51,1,0,0,0,397,402,3,76,38,0,398,399,3,66,33,
  	0,399,400,3,76,38,0,400,402,1,0,0,0,401,397,1,0,0,0,401,398,1,0,0,0,402,
  	53,1,0,0,0,403,404,5,65,0,0,404,55,1,0,0,0,405,406,7,7,0,0,406,57,1,0,
  	0,0,407,408,5,93,0,0,408,409,5,226,0,0,409,410,3,60,30,0,410,411,5,241,
  	0,0,411,59,1,0,0,0,412,417,3,62,31,0,413,414,5,211,0,0,414,416,3,62,31,
  	0,415,413,1,0,0,0,416,419,1,0,0,0,417,415,1,0,0,0,417,418,1,0,0,0,418,
  	61,1,0,0,0,419,417,1,0,0,0,420,423,5,257,0,0,421,422,5,217,0,0,422,424,
  	3,30,15,0,423,421,1,0,0,0,423,424,1,0,0,0,424,427,1,0,0,0,425,427,5,137,
  	0,0,426,420,1,0,0,0,426,425,1,0,0,0,427,63,1,0,0,0,428,429,5,111,0,0,
  	429,65,1,0,0,0,430,432,3,68,34,0,431,430,1,0,0,0,432,433,1,0,0,0,433,
  	431,1,0,0,0,433,434,1,0,0,0,434,67,1,0,0,0,435,442,3,70,35,0,436,442,
  	3,58,29,0,437,442,3,84,42,0,438,442,3,56,28,0,439,442,3,54,27,0,440,442,
  	3,64,32,0,441,435,1,0,0,0,441,436,1,0,0,0,441,437,1,0,0,0,441,438,1,0,
  	0,0,441,439,1,0,0,0,441,440,1,0,0,0,442,69,1,0,0,0,443,468,5,12,0,0,444,
  	468,5,62,0,0,445,468,5,109,0,0,446,468,5,63,0,0,447,468,5,10,0,0,448,
  	468,5,110,0,0,449,468,5,116,0,0,450,468,5,168,0,0,451,468,5,5,0,0,452,
  	468,5,137,0,0,453,468,5,11,0,0,454,468,5,201,0,0,455,468,5,114,0,0,456,
  	468,5,113,0,0,457,468,5,203,0,0,458,463,5,142,0,0,459,460,5,226,0,0,460,
  	461,3,72,36,0,461,462,5,241,0,0,462,464,1,0,0,0,463,459,1,0,0,0,463,464,
  	1,0,0,0,464,468,1,0,0,0,465,468,5,2,0,0,466,468,5,196,0,0,467,443,1,0,
  	0,0,467,444,1,0,0,0,467,445,1,0,0,0,467,446,1,0,0,0,467,447,1,0,0,0,467,
  	448,1,0,0,0,467,449,1,0,0,0,467,450,1,0,0,0,467,451,1,0,0,0,467,452,1,
  	0,0,0,467,453,1,0,0,0,467,454,1,0,0,0,467,455,1,0,0,0,467,456,1,0,0,0,
  	467,457,1,0,0,0,467,458,1,0,0,0,467,465,1,0,0,0,467,466,1,0,0,0,468,71,
  	1,0,0,0,469,474,3,74,37,0,470,471,5,211,0,0,471,473,3,74,37,0,472,470,
  	1,0,0,0,473,476,1,0,0,0,474,472,1,0,0,0,474,475,1,0,0,0,475,73,1,0,0,
  	0,476,474,1,0,0,0,477,478,5,257,0,0,478,75,1,0,0,0,479,481,3,82,41,0,
  	480,482,3,78,39,0,481,480,1,0,0,0,481,482,1,0,0,0,482,77,1,0,0,0,483,
  	485,3,80,40,0,484,483,1,0,0,0,485,486,1,0,0,0,486,484,1,0,0,0,486,487,
  	1,0,0,0,487,79,1,0,0,0,488,490,5,224,0,0,489,491,3,30,15,0,490,489,1,
  	0,0,0,490,491,1,0,0,0,491,492,1,0,0,0,492,493,5,239,0,0,493,81,1,0,0,
  	0,494,616,5,200,0,0,495,616,5,36,0,0,496,616,5,29,0,0,497,616,5,64,0,
  	0,498,616,5,167,0,0,499,616,5,3,0,0,500,616,5,197,0,0,501,616,5,198,0,
  	0,502,616,5,199,0,0,503,616,5,30,0,0,504,616,5,31,0,0,505,616,5,32,0,
  	0,506,616,5,6,0,0,507,616,5,7,0,0,508,616,5,8,0,0,509,616,5,90,0,0,510,
  	616,5,91,0,0,511,616,5,92,0,0,512,616,5,193,0,0,513,616,5,194,0,0,514,
  	616,5,195,0,0,515,616,5,95,0,0,516,616,5,99,0,0,517,616,5,103,0,0,518,
  	616,5,96,0,0,519,616,5,97,0,0,520,616,5,98,0,0,521,616,5,100,0,0,522,
  	616,5,101,0,0,523,616,5,102,0,0,524,616,5,104,0,0,525,616,5,105,0,0,526,
  	616,5,106,0,0,527,616,5,16,0,0,528,616,5,20,0,0,529,616,5,24,0,0,530,
  	616,5,17,0,0,531,616,5,18,0,0,532,616,5,19,0,0,533,616,5,21,0,0,534,616,
  	5,22,0,0,535,616,5,23,0,0,536,616,5,25,0,0,537,616,5,26,0,0,538,616,5,
  	27,0,0,539,616,5,1,0,0,540,616,5,122,0,0,541,616,5,130,0,0,542,616,5,
  	132,0,0,543,616,5,129,0,0,544,616,5,135,0,0,545,616,5,123,0,0,546,616,
  	5,124,0,0,547,616,5,133,0,0,548,616,5,134,0,0,549,616,5,68,0,0,550,616,
  	5,73,0,0,551,616,5,75,0,0,552,616,5,69,0,0,553,616,5,76,0,0,554,616,5,
  	171,0,0,555,616,5,176,0,0,556,616,5,178,0,0,557,616,5,172,0,0,558,616,
  	5,179,0,0,559,616,5,118,0,0,560,616,5,121,0,0,561,616,5,119,0,0,562,616,
  	5,120,0,0,563,616,5,66,0,0,564,616,5,67,0,0,565,616,5,169,0,0,566,616,
  	5,170,0,0,567,616,5,127,0,0,568,616,5,128,0,0,569,616,5,72,0,0,570,616,
  	5,175,0,0,571,616,5,131,0,0,572,616,5,74,0,0,573,616,5,177,0,0,574,616,
  	5,125,0,0,575,616,5,70,0,0,576,616,5,173,0,0,577,616,5,126,0,0,578,616,
  	5,71,0,0,579,616,5,174,0,0,580,616,5,53,0,0,581,616,5,42,0,0,582,616,
  	5,158,0,0,583,616,5,58,0,0,584,616,5,47,0,0,585,616,5,163,0,0,586,616,
  	5,60,0,0,587,616,5,49,0,0,588,616,5,165,0,0,589,616,5,59,0,0,590,616,
  	5,48,0,0,591,616,5,164,0,0,592,616,5,51,0,0,593,616,5,40,0,0,594,616,
  	5,156,0,0,595,616,5,52,0,0,596,616,5,41,0,0,597,616,5,157,0,0,598,616,
  	5,57,0,0,599,616,5,46,0,0,600,616,5,162,0,0,601,616,5,54,0,0,602,616,
  	5,43,0,0,603,616,5,159,0,0,604,616,5,61,0,0,605,616,5,50,0,0,606,616,
  	5,166,0,0,607,616,5,55,0,0,608,616,5,44,0,0,609,616,5,160,0,0,610,616,
  	5,56,0,0,611,616,5,45,0,0,612,616,5,161,0,0,613,616,3,86,43,0,614,616,
  	3,74,37,0,615,494,1,0,0,0,615,495,1,0,0,0,615,496,1,0,0,0,615,497,1,0,
  	0,0,615,498,1,0,0,0,615,499,1,0,0,0,615,500,1,0,0,0,615,501,1,0,0,0,615,
  	502,1,0,0,0,615,503,1,0,0,0,615,504,1,0,0,0,615,505,1,0,0,0,615,506,1,
  	0,0,0,615,507,1,0,0,0,615,508,1,0,0,0,615,509,1,0,0,0,615,510,1,0,0,0,
  	615,511,1,0,0,0,615,512,1,0,0,0,615,513,1,0,0,0,615,514,1,0,0,0,615,515,
  	1,0,0,0,615,516,1,0,0,0,615,517,1,0,0,0,615,518,1,0,0,0,615,519,1,0,0,
  	0,615,520,1,0,0,0,615,521,1,0,0,0,615,522,1,0,0,0,615,523,1,0,0,0,615,
  	524,1,0,0,0,615,525,1,0,0,0,615,526,1,0,0,0,615,527,1,0,0,0,615,528,1,
  	0,0,0,615,529,1,0,0,0,615,530,1,0,0,0,615,531,1,0,0,0,615,532,1,0,0,0,
  	615,533,1,0,0,0,615,534,1,0,0,0,615,535,1,0,0,0,615,536,1,0,0,0,615,537,
  	1,0,0,0,615,538,1,0,0,0,615,539,1,0,0,0,615,540,1,0,0,0,615,541,1,0,0,
  	0,615,542,1,0,0,0,615,543,1,0,0,0,615,544,1,0,0,0,615,545,1,0,0,0,615,
  	546,1,0,0,0,615,547,1,0,0,0,615,548,1,0,0,0,615,549,1,0,0,0,615,550,1,
  	0,0,0,615,551,1,0,0,0,615,552,1,0,0,0,615,553,1,0,0,0,615,554,1,0,0,0,
  	615,555,1,0,0,0,615,556,1,0,0,0,615,557,1,0,0,0,615,558,1,0,0,0,615,559,
  	1,0,0,0,615,560,1,0,0,0,615,561,1,0,0,0,615,562,1,0,0,0,615,563,1,0,0,
  	0,615,564,1,0,0,0,615,565,1,0,0,0,615,566,1,0,0,0,615,567,1,0,0,0,615,
  	568,1,0,0,0,615,569,1,0,0,0,615,570,1,0,0,0,615,571,1,0,0,0,615,572,1,
  	0,0,0,615,573,1,0,0,0,615,574,1,0,0,0,615,575,1,0,0,0,615,576,1,0,0,0,
  	615,577,1,0,0,0,615,578,1,0,0,0,615,579,1,0,0,0,615,580,1,0,0,0,615,581,
  	1,0,0,0,615,582,1,0,0,0,615,583,1,0,0,0,615,584,1,0,0,0,615,585,1,0,0,
  	0,615,586,1,0,0,0,615,587,1,0,0,0,615,588,1,0,0,0,615,589,1,0,0,0,615,
  	590,1,0,0,0,615,591,1,0,0,0,615,592,1,0,0,0,615,593,1,0,0,0,615,594,1,
  	0,0,0,615,595,1,0,0,0,615,596,1,0,0,0,615,597,1,0,0,0,615,598,1,0,0,0,
  	615,599,1,0,0,0,615,600,1,0,0,0,615,601,1,0,0,0,615,602,1,0,0,0,615,603,
  	1,0,0,0,615,604,1,0,0,0,615,605,1,0,0,0,615,606,1,0,0,0,615,607,1,0,0,
  	0,615,608,1,0,0,0,615,609,1,0,0,0,615,610,1,0,0,0,615,611,1,0,0,0,615,
  	612,1,0,0,0,615,613,1,0,0,0,615,614,1,0,0,0,616,83,1,0,0,0,617,618,7,
  	8,0,0,618,85,1,0,0,0,619,621,5,139,0,0,620,622,5,257,0,0,621,620,1,0,
  	0,0,621,622,1,0,0,0,622,623,1,0,0,0,623,624,5,223,0,0,624,625,3,88,44,
  	0,625,626,5,238,0,0,626,87,1,0,0,0,627,629,3,90,45,0,628,627,1,0,0,0,
  	629,630,1,0,0,0,630,628,1,0,0,0,630,631,1,0,0,0,631,89,1,0,0,0,632,633,
  	3,76,38,0,633,634,3,92,46,0,634,635,5,242,0,0,635,642,1,0,0,0,636,637,
  	3,66,33,0,637,638,3,76,38,0,638,639,3,92,46,0,639,640,5,242,0,0,640,642,
  	1,0,0,0,641,632,1,0,0,0,641,636,1,0,0,0,642,91,1,0,0,0,643,648,3,94,47,
  	0,644,645,5,211,0,0,645,647,3,94,47,0,646,644,1,0,0,0,647,650,1,0,0,0,
  	648,646,1,0,0,0,648,649,1,0,0,0,649,93,1,0,0,0,650,648,1,0,0,0,651,653,
  	5,257,0,0,652,654,3,78,39,0,653,652,1,0,0,0,653,654,1,0,0,0,654,95,1,
  	0,0,0,655,664,3,22,11,0,656,657,5,223,0,0,657,659,3,98,49,0,658,660,5,
  	211,0,0,659,658,1,0,0,0,659,660,1,0,0,0,660,661,1,0,0,0,661,662,5,238,
  	0,0,662,664,1,0,0,0,663,655,1,0,0,0,663,656,1,0,0,0,664,97,1,0,0,0,665,
  	670,3,96,48,0,666,667,5,211,0,0,667,669,3,96,48,0,668,666,1,0,0,0,669,
  	672,1,0,0,0,670,668,1,0,0,0,670,671,1,0,0,0,671,99,1,0,0,0,672,670,1,
  	0,0,0,673,674,3,32,16,0,674,101,1,0,0,0,675,678,3,106,53,0,676,678,3,
  	104,52,0,677,675,1,0,0,0,677,676,1,0,0,0,678,103,1,0,0,0,679,687,3,100,
  	50,0,680,687,3,114,57,0,681,687,3,116,58,0,682,687,3,122,61,0,683,687,
  	3,124,62,0,684,687,3,126,63,0,685,687,3,132,66,0,686,679,1,0,0,0,686,
  	680,1,0,0,0,686,681,1,0,0,0,686,682,1,0,0,0,686,683,1,0,0,0,686,684,1,
  	0,0,0,686,685,1,0,0,0,687,105,1,0,0,0,688,690,5,223,0,0,689,691,3,112,
  	56,0,690,689,1,0,0,0,690,691,1,0,0,0,691,692,1,0,0,0,692,693,5,238,0,
  	0,693,107,1,0,0,0,694,697,3,110,55,0,695,697,3,104,52,0,696,694,1,0,0,
  	0,696,695,1,0,0,0,697,109,1,0,0,0,698,700,5,223,0,0,699,701,3,112,56,
  	0,700,699,1,0,0,0,700,701,1,0,0,0,701,702,1,0,0,0,702,703,5,238,0,0,703,
  	111,1,0,0,0,704,706,3,102,51,0,705,704,1,0,0,0,706,707,1,0,0,0,707,705,
  	1,0,0,0,707,708,1,0,0,0,708,113,1,0,0,0,709,714,5,242,0,0,710,711,3,28,
  	14,0,711,712,5,242,0,0,712,714,1,0,0,0,713,709,1,0,0,0,713,710,1,0,0,
  	0,714,115,1,0,0,0,715,716,5,39,0,0,716,717,5,226,0,0,717,718,3,28,14,
  	0,718,719,5,241,0,0,719,720,3,118,59,0,720,117,1,0,0,0,721,724,3,102,
  	51,0,722,723,5,33,0,0,723,725,3,102,51,0,724,722,1,0,0,0,724,725,1,0,
  	0,0,725,119,1,0,0,0,726,733,3,28,14,0,727,728,3,52,26,0,728,729,5,257,
  	0,0,729,730,5,217,0,0,730,731,3,96,48,0,731,733,1,0,0,0,732,726,1,0,0,
  	0,732,727,1,0,0,0,733,121,1,0,0,0,734,735,5,143,0,0,735,736,5,226,0,0,
  	736,737,3,28,14,0,737,738,5,241,0,0,738,740,5,223,0,0,739,741,3,112,56,
  	0,740,739,1,0,0,0,740,741,1,0,0,0,741,742,1,0,0,0,742,743,5,238,0,0,743,
  	123,1,0,0,0,744,745,5,9,0,0,745,746,3,28,14,0,746,747,5,210,0,0,747,751,
  	1,0,0,0,748,749,5,14,0,0,749,751,5,210,0,0,750,744,1,0,0,0,750,748,1,
  	0,0,0,751,125,1,0,0,0,752,753,5,202,0,0,753,754,5,226,0,0,754,755,3,120,
  	60,0,755,756,5,241,0,0,756,757,3,108,54,0,757,774,1,0,0,0,758,759,5,28,
  	0,0,759,760,3,102,51,0,760,761,5,202,0,0,761,762,5,226,0,0,762,763,3,
  	28,14,0,763,764,5,241,0,0,764,765,5,242,0,0,765,774,1,0,0,0,766,767,5,
  	37,0,0,767,768,5,226,0,0,768,769,3,128,64,0,769,770,3,130,65,0,770,771,
  	5,241,0,0,771,772,3,108,54,0,772,774,1,0,0,0,773,752,1,0,0,0,773,758,
  	1,0,0,0,773,766,1,0,0,0,774,127,1,0,0,0,775,778,3,114,57,0,776,778,3,
  	100,50,0,777,775,1,0,0,0,777,776,1,0,0,0,778,129,1,0,0,0,779,781,3,120,
  	60,0,780,779,1,0,0,0,780,781,1,0,0,0,781,782,1,0,0,0,782,784,5,242,0,
  	0,783,785,3,28,14,0,784,783,1,0,0,0,784,785,1,0,0,0,785,131,1,0,0,0,786,
  	787,5,13,0,0,787,798,5,242,0,0,788,789,5,4,0,0,789,798,5,242,0,0,790,
  	792,5,115,0,0,791,793,3,28,14,0,792,791,1,0,0,0,792,793,1,0,0,0,793,794,
  	1,0,0,0,794,798,5,242,0,0,795,796,5,15,0,0,796,798,5,242,0,0,797,786,
  	1,0,0,0,797,788,1,0,0,0,797,790,1,0,0,0,797,795,1,0,0,0,798,133,1,0,0,
  	0,799,803,3,136,68,0,800,803,3,32,16,0,801,803,5,242,0,0,802,799,1,0,
  	0,0,802,800,1,0,0,0,802,801,1,0,0,0,803,135,1,0,0,0,804,805,3,36,18,0,
  	805,806,3,110,55,0,806,137,1,0,0,0,71,141,159,166,170,180,190,192,197,
  	204,210,217,221,231,240,280,282,293,303,323,325,331,335,342,349,358,364,
  	369,373,382,387,391,395,401,417,423,426,433,441,463,467,474,481,486,490,
  	615,621,630,641,648,653,659,663,670,677,686,690,696,700,707,713,724,732,
  	740,750,773,777,780,784,792,797,802
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  glslparserParserStaticData = staticData.release();
}

}

GLSLParser::GLSLParser(TokenStream *input) : GLSLParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

GLSLParser::GLSLParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  GLSLParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *glslparserParserStaticData->atn, glslparserParserStaticData->decisionToDFA, glslparserParserStaticData->sharedContextCache, options);
}

GLSLParser::~GLSLParser() {
  delete _interpreter;
}

const atn::ATN& GLSLParser::getATN() const {
  return *glslparserParserStaticData->atn;
}

std::string GLSLParser::getGrammarFileName() const {
  return "GLSLParser.g4";
}

const std::vector<std::string>& GLSLParser::getRuleNames() const {
  return glslparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& GLSLParser::getVocabulary() const {
  return glslparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView GLSLParser::getSerializedATN() const {
  return glslparserParserStaticData->serializedATN;
}


//----------------- Translation_unitContext ------------------------------------------------------------------

GLSLParser::Translation_unitContext::Translation_unitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Translation_unitContext::EOF() {
  return getToken(GLSLParser::EOF, 0);
}

std::vector<GLSLParser::External_declarationContext *> GLSLParser::Translation_unitContext::external_declaration() {
  return getRuleContexts<GLSLParser::External_declarationContext>();
}

GLSLParser::External_declarationContext* GLSLParser::Translation_unitContext::external_declaration(size_t i) {
  return getRuleContext<GLSLParser::External_declarationContext>(i);
}


size_t GLSLParser::Translation_unitContext::getRuleIndex() const {
  return GLSLParser::RuleTranslation_unit;
}

void GLSLParser::Translation_unitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTranslation_unit(this);
}

void GLSLParser::Translation_unitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTranslation_unit(this);
}

GLSLParser::Translation_unitContext* GLSLParser::translation_unit() {
  Translation_unitContext *_localctx = _tracker.createInstance<Translation_unitContext>(_ctx, getState());
  enterRule(_localctx, 0, GLSLParser::RuleTranslation_unit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(141);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -713233064466) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -11258999135526913) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 4503599358955263) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & 562949953422847) != 0) || _la == GLSLParser::IDENTIFIER) {
      setState(138);
      external_declaration();
      setState(143);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(144);
    match(GLSLParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_identifierContext ------------------------------------------------------------------

GLSLParser::Variable_identifierContext::Variable_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Variable_identifierContext::IDENTIFIER() {
  return getToken(GLSLParser::IDENTIFIER, 0);
}


size_t GLSLParser::Variable_identifierContext::getRuleIndex() const {
  return GLSLParser::RuleVariable_identifier;
}

void GLSLParser::Variable_identifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_identifier(this);
}

void GLSLParser::Variable_identifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_identifier(this);
}

GLSLParser::Variable_identifierContext* GLSLParser::variable_identifier() {
  Variable_identifierContext *_localctx = _tracker.createInstance<Variable_identifierContext>(_ctx, getState());
  enterRule(_localctx, 2, GLSLParser::RuleVariable_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(146);
    match(GLSLParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Primary_expressionContext ------------------------------------------------------------------

GLSLParser::Primary_expressionContext::Primary_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Variable_identifierContext* GLSLParser::Primary_expressionContext::variable_identifier() {
  return getRuleContext<GLSLParser::Variable_identifierContext>(0);
}

tree::TerminalNode* GLSLParser::Primary_expressionContext::TRUE() {
  return getToken(GLSLParser::TRUE, 0);
}

tree::TerminalNode* GLSLParser::Primary_expressionContext::FALSE() {
  return getToken(GLSLParser::FALSE, 0);
}

tree::TerminalNode* GLSLParser::Primary_expressionContext::INTCONSTANT() {
  return getToken(GLSLParser::INTCONSTANT, 0);
}

tree::TerminalNode* GLSLParser::Primary_expressionContext::UINTCONSTANT() {
  return getToken(GLSLParser::UINTCONSTANT, 0);
}

tree::TerminalNode* GLSLParser::Primary_expressionContext::FLOATCONSTANT() {
  return getToken(GLSLParser::FLOATCONSTANT, 0);
}

tree::TerminalNode* GLSLParser::Primary_expressionContext::DOUBLECONSTANT() {
  return getToken(GLSLParser::DOUBLECONSTANT, 0);
}

tree::TerminalNode* GLSLParser::Primary_expressionContext::LEFT_PAREN() {
  return getToken(GLSLParser::LEFT_PAREN, 0);
}

GLSLParser::ExpressionContext* GLSLParser::Primary_expressionContext::expression() {
  return getRuleContext<GLSLParser::ExpressionContext>(0);
}

tree::TerminalNode* GLSLParser::Primary_expressionContext::RIGHT_PAREN() {
  return getToken(GLSLParser::RIGHT_PAREN, 0);
}


size_t GLSLParser::Primary_expressionContext::getRuleIndex() const {
  return GLSLParser::RulePrimary_expression;
}

void GLSLParser::Primary_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimary_expression(this);
}

void GLSLParser::Primary_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimary_expression(this);
}

GLSLParser::Primary_expressionContext* GLSLParser::primary_expression() {
  Primary_expressionContext *_localctx = _tracker.createInstance<Primary_expressionContext>(_ctx, getState());
  enterRule(_localctx, 4, GLSLParser::RulePrimary_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(159);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GLSLParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(148);
        variable_identifier();
        break;
      }

      case GLSLParser::TRUE: {
        enterOuterAlt(_localctx, 2);
        setState(149);
        match(GLSLParser::TRUE);
        break;
      }

      case GLSLParser::FALSE: {
        enterOuterAlt(_localctx, 3);
        setState(150);
        match(GLSLParser::FALSE);
        break;
      }

      case GLSLParser::INTCONSTANT: {
        enterOuterAlt(_localctx, 4);
        setState(151);
        match(GLSLParser::INTCONSTANT);
        break;
      }

      case GLSLParser::UINTCONSTANT: {
        enterOuterAlt(_localctx, 5);
        setState(152);
        match(GLSLParser::UINTCONSTANT);
        break;
      }

      case GLSLParser::FLOATCONSTANT: {
        enterOuterAlt(_localctx, 6);
        setState(153);
        match(GLSLParser::FLOATCONSTANT);
        break;
      }

      case GLSLParser::DOUBLECONSTANT: {
        enterOuterAlt(_localctx, 7);
        setState(154);
        match(GLSLParser::DOUBLECONSTANT);
        break;
      }

      case GLSLParser::LEFT_PAREN: {
        enterOuterAlt(_localctx, 8);
        setState(155);
        match(GLSLParser::LEFT_PAREN);
        setState(156);
        expression(0);
        setState(157);
        match(GLSLParser::RIGHT_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Postfix_expressionContext ------------------------------------------------------------------

GLSLParser::Postfix_expressionContext::Postfix_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Primary_expressionContext* GLSLParser::Postfix_expressionContext::primary_expression() {
  return getRuleContext<GLSLParser::Primary_expressionContext>(0);
}

GLSLParser::Type_specifierContext* GLSLParser::Postfix_expressionContext::type_specifier() {
  return getRuleContext<GLSLParser::Type_specifierContext>(0);
}

tree::TerminalNode* GLSLParser::Postfix_expressionContext::LEFT_PAREN() {
  return getToken(GLSLParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GLSLParser::Postfix_expressionContext::RIGHT_PAREN() {
  return getToken(GLSLParser::RIGHT_PAREN, 0);
}

GLSLParser::Function_call_parametersContext* GLSLParser::Postfix_expressionContext::function_call_parameters() {
  return getRuleContext<GLSLParser::Function_call_parametersContext>(0);
}

GLSLParser::Postfix_expressionContext* GLSLParser::Postfix_expressionContext::postfix_expression() {
  return getRuleContext<GLSLParser::Postfix_expressionContext>(0);
}

tree::TerminalNode* GLSLParser::Postfix_expressionContext::LEFT_BRACKET() {
  return getToken(GLSLParser::LEFT_BRACKET, 0);
}

GLSLParser::Integer_expressionContext* GLSLParser::Postfix_expressionContext::integer_expression() {
  return getRuleContext<GLSLParser::Integer_expressionContext>(0);
}

tree::TerminalNode* GLSLParser::Postfix_expressionContext::RIGHT_BRACKET() {
  return getToken(GLSLParser::RIGHT_BRACKET, 0);
}

tree::TerminalNode* GLSLParser::Postfix_expressionContext::DOT() {
  return getToken(GLSLParser::DOT, 0);
}

GLSLParser::Field_selectionContext* GLSLParser::Postfix_expressionContext::field_selection() {
  return getRuleContext<GLSLParser::Field_selectionContext>(0);
}

tree::TerminalNode* GLSLParser::Postfix_expressionContext::INC_OP() {
  return getToken(GLSLParser::INC_OP, 0);
}

tree::TerminalNode* GLSLParser::Postfix_expressionContext::DEC_OP() {
  return getToken(GLSLParser::DEC_OP, 0);
}


size_t GLSLParser::Postfix_expressionContext::getRuleIndex() const {
  return GLSLParser::RulePostfix_expression;
}

void GLSLParser::Postfix_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostfix_expression(this);
}

void GLSLParser::Postfix_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostfix_expression(this);
}


GLSLParser::Postfix_expressionContext* GLSLParser::postfix_expression() {
   return postfix_expression(0);
}

GLSLParser::Postfix_expressionContext* GLSLParser::postfix_expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  GLSLParser::Postfix_expressionContext *_localctx = _tracker.createInstance<Postfix_expressionContext>(_ctx, parentState);
  GLSLParser::Postfix_expressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 6;
  enterRecursionRule(_localctx, 6, GLSLParser::RulePostfix_expression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(170);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
    case 1: {
      setState(162);
      primary_expression();
      break;
    }

    case 2: {
      setState(163);
      type_specifier();
      setState(164);
      match(GLSLParser::LEFT_PAREN);
      setState(166);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 1) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1)) & -6917529530286505755) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 66)) & -4501401023543297) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 130)) & -9222246411859393985) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 194)) & -8138003422817533829) != 0)) {
        setState(165);
        function_call_parameters();
      }
      setState(168);
      match(GLSLParser::RIGHT_PAREN);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(192);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(190);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Postfix_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePostfix_expression);
          setState(172);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(173);
          match(GLSLParser::LEFT_BRACKET);
          setState(174);
          integer_expression();
          setState(175);
          match(GLSLParser::RIGHT_BRACKET);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Postfix_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePostfix_expression);
          setState(177);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(178);
          match(GLSLParser::LEFT_PAREN);
          setState(180);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (((((_la - 1) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 1)) & -6917529530286505755) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 66)) & -4501401023543297) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 130)) & -9222246411859393985) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 194)) & -8138003422817533829) != 0)) {
            setState(179);
            function_call_parameters();
          }
          setState(182);
          match(GLSLParser::RIGHT_PAREN);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<Postfix_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePostfix_expression);
          setState(183);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(184);
          match(GLSLParser::DOT);
          setState(185);
          field_selection();
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<Postfix_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePostfix_expression);
          setState(186);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(187);
          match(GLSLParser::INC_OP);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<Postfix_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePostfix_expression);
          setState(188);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(189);
          match(GLSLParser::DEC_OP);
          break;
        }

        default:
          break;
        } 
      }
      setState(194);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Field_selectionContext ------------------------------------------------------------------

GLSLParser::Field_selectionContext::Field_selectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Variable_identifierContext* GLSLParser::Field_selectionContext::variable_identifier() {
  return getRuleContext<GLSLParser::Variable_identifierContext>(0);
}

GLSLParser::Function_callContext* GLSLParser::Field_selectionContext::function_call() {
  return getRuleContext<GLSLParser::Function_callContext>(0);
}


size_t GLSLParser::Field_selectionContext::getRuleIndex() const {
  return GLSLParser::RuleField_selection;
}

void GLSLParser::Field_selectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterField_selection(this);
}

void GLSLParser::Field_selectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitField_selection(this);
}

GLSLParser::Field_selectionContext* GLSLParser::field_selection() {
  Field_selectionContext *_localctx = _tracker.createInstance<Field_selectionContext>(_ctx, getState());
  enterRule(_localctx, 8, GLSLParser::RuleField_selection);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(197);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(195);
      variable_identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(196);
      function_call();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Integer_expressionContext ------------------------------------------------------------------

GLSLParser::Integer_expressionContext::Integer_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::ExpressionContext* GLSLParser::Integer_expressionContext::expression() {
  return getRuleContext<GLSLParser::ExpressionContext>(0);
}


size_t GLSLParser::Integer_expressionContext::getRuleIndex() const {
  return GLSLParser::RuleInteger_expression;
}

void GLSLParser::Integer_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInteger_expression(this);
}

void GLSLParser::Integer_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInteger_expression(this);
}

GLSLParser::Integer_expressionContext* GLSLParser::integer_expression() {
  Integer_expressionContext *_localctx = _tracker.createInstance<Integer_expressionContext>(_ctx, getState());
  enterRule(_localctx, 10, GLSLParser::RuleInteger_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(199);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_callContext ------------------------------------------------------------------

GLSLParser::Function_callContext::Function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Function_identifierContext* GLSLParser::Function_callContext::function_identifier() {
  return getRuleContext<GLSLParser::Function_identifierContext>(0);
}

tree::TerminalNode* GLSLParser::Function_callContext::LEFT_PAREN() {
  return getToken(GLSLParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GLSLParser::Function_callContext::RIGHT_PAREN() {
  return getToken(GLSLParser::RIGHT_PAREN, 0);
}

GLSLParser::Function_call_parametersContext* GLSLParser::Function_callContext::function_call_parameters() {
  return getRuleContext<GLSLParser::Function_call_parametersContext>(0);
}


size_t GLSLParser::Function_callContext::getRuleIndex() const {
  return GLSLParser::RuleFunction_call;
}

void GLSLParser::Function_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_call(this);
}

void GLSLParser::Function_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_call(this);
}

GLSLParser::Function_callContext* GLSLParser::function_call() {
  Function_callContext *_localctx = _tracker.createInstance<Function_callContext>(_ctx, getState());
  enterRule(_localctx, 12, GLSLParser::RuleFunction_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(201);
    function_identifier();
    setState(202);
    match(GLSLParser::LEFT_PAREN);
    setState(204);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 1) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1)) & -6917529530286505755) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & -4501401023543297) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 130)) & -9222246411859393985) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 194)) & -8138003422817533829) != 0)) {
      setState(203);
      function_call_parameters();
    }
    setState(206);
    match(GLSLParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_identifierContext ------------------------------------------------------------------

GLSLParser::Function_identifierContext::Function_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Type_specifierContext* GLSLParser::Function_identifierContext::type_specifier() {
  return getRuleContext<GLSLParser::Type_specifierContext>(0);
}

GLSLParser::Postfix_expressionContext* GLSLParser::Function_identifierContext::postfix_expression() {
  return getRuleContext<GLSLParser::Postfix_expressionContext>(0);
}


size_t GLSLParser::Function_identifierContext::getRuleIndex() const {
  return GLSLParser::RuleFunction_identifier;
}

void GLSLParser::Function_identifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_identifier(this);
}

void GLSLParser::Function_identifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_identifier(this);
}

GLSLParser::Function_identifierContext* GLSLParser::function_identifier() {
  Function_identifierContext *_localctx = _tracker.createInstance<Function_identifierContext>(_ctx, getState());
  enterRule(_localctx, 14, GLSLParser::RuleFunction_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(210);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(208);
      type_specifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(209);
      postfix_expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_call_parametersContext ------------------------------------------------------------------

GLSLParser::Function_call_parametersContext::Function_call_parametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GLSLParser::Assignment_expressionContext *> GLSLParser::Function_call_parametersContext::assignment_expression() {
  return getRuleContexts<GLSLParser::Assignment_expressionContext>();
}

GLSLParser::Assignment_expressionContext* GLSLParser::Function_call_parametersContext::assignment_expression(size_t i) {
  return getRuleContext<GLSLParser::Assignment_expressionContext>(i);
}

std::vector<tree::TerminalNode *> GLSLParser::Function_call_parametersContext::COMMA() {
  return getTokens(GLSLParser::COMMA);
}

tree::TerminalNode* GLSLParser::Function_call_parametersContext::COMMA(size_t i) {
  return getToken(GLSLParser::COMMA, i);
}

tree::TerminalNode* GLSLParser::Function_call_parametersContext::VOID() {
  return getToken(GLSLParser::VOID, 0);
}


size_t GLSLParser::Function_call_parametersContext::getRuleIndex() const {
  return GLSLParser::RuleFunction_call_parameters;
}

void GLSLParser::Function_call_parametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_call_parameters(this);
}

void GLSLParser::Function_call_parametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_call_parameters(this);
}

GLSLParser::Function_call_parametersContext* GLSLParser::function_call_parameters() {
  Function_call_parametersContext *_localctx = _tracker.createInstance<Function_call_parametersContext>(_ctx, getState());
  enterRule(_localctx, 16, GLSLParser::RuleFunction_call_parameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(221);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(212);
      assignment_expression();
      setState(217);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GLSLParser::COMMA) {
        setState(213);
        match(GLSLParser::COMMA);
        setState(214);
        assignment_expression();
        setState(219);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(220);
      match(GLSLParser::VOID);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_expressionContext ------------------------------------------------------------------

GLSLParser::Unary_expressionContext::Unary_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Postfix_expressionContext* GLSLParser::Unary_expressionContext::postfix_expression() {
  return getRuleContext<GLSLParser::Postfix_expressionContext>(0);
}

tree::TerminalNode* GLSLParser::Unary_expressionContext::INC_OP() {
  return getToken(GLSLParser::INC_OP, 0);
}

GLSLParser::Unary_expressionContext* GLSLParser::Unary_expressionContext::unary_expression() {
  return getRuleContext<GLSLParser::Unary_expressionContext>(0);
}

tree::TerminalNode* GLSLParser::Unary_expressionContext::DEC_OP() {
  return getToken(GLSLParser::DEC_OP, 0);
}

GLSLParser::Unary_operatorContext* GLSLParser::Unary_expressionContext::unary_operator() {
  return getRuleContext<GLSLParser::Unary_operatorContext>(0);
}


size_t GLSLParser::Unary_expressionContext::getRuleIndex() const {
  return GLSLParser::RuleUnary_expression;
}

void GLSLParser::Unary_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnary_expression(this);
}

void GLSLParser::Unary_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnary_expression(this);
}

GLSLParser::Unary_expressionContext* GLSLParser::unary_expression() {
  Unary_expressionContext *_localctx = _tracker.createInstance<Unary_expressionContext>(_ctx, getState());
  enterRule(_localctx, 18, GLSLParser::RuleUnary_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(231);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GLSLParser::ATOMIC_UINT:
      case GLSLParser::BOOL:
      case GLSLParser::BVEC2:
      case GLSLParser::BVEC3:
      case GLSLParser::BVEC4:
      case GLSLParser::DMAT2:
      case GLSLParser::DMAT2X2:
      case GLSLParser::DMAT2X3:
      case GLSLParser::DMAT2X4:
      case GLSLParser::DMAT3:
      case GLSLParser::DMAT3X2:
      case GLSLParser::DMAT3X3:
      case GLSLParser::DMAT3X4:
      case GLSLParser::DMAT4:
      case GLSLParser::DMAT4X2:
      case GLSLParser::DMAT4X3:
      case GLSLParser::DMAT4X4:
      case GLSLParser::DOUBLE:
      case GLSLParser::DVEC2:
      case GLSLParser::DVEC3:
      case GLSLParser::DVEC4:
      case GLSLParser::FALSE:
      case GLSLParser::FLOAT:
      case GLSLParser::IIMAGE1D:
      case GLSLParser::IIMAGE1DARRAY:
      case GLSLParser::IIMAGE2D:
      case GLSLParser::IIMAGE2DARRAY:
      case GLSLParser::IIMAGE2DMS:
      case GLSLParser::IIMAGE2DMSARRAY:
      case GLSLParser::IIMAGE2DRECT:
      case GLSLParser::IIMAGE3D:
      case GLSLParser::IIMAGEBUFFER:
      case GLSLParser::IIMAGECUBE:
      case GLSLParser::IIMAGECUBEARRAY:
      case GLSLParser::IMAGE1D:
      case GLSLParser::IMAGE1DARRAY:
      case GLSLParser::IMAGE2D:
      case GLSLParser::IMAGE2DARRAY:
      case GLSLParser::IMAGE2DMS:
      case GLSLParser::IMAGE2DMSARRAY:
      case GLSLParser::IMAGE2DRECT:
      case GLSLParser::IMAGE3D:
      case GLSLParser::IMAGEBUFFER:
      case GLSLParser::IMAGECUBE:
      case GLSLParser::IMAGECUBEARRAY:
      case GLSLParser::INT:
      case GLSLParser::ISAMPLER1D:
      case GLSLParser::ISAMPLER1DARRAY:
      case GLSLParser::ISAMPLER2D:
      case GLSLParser::ISAMPLER2DARRAY:
      case GLSLParser::ISAMPLER2DMS:
      case GLSLParser::ISAMPLER2DMSARRAY:
      case GLSLParser::ISAMPLER2DRECT:
      case GLSLParser::ISAMPLER3D:
      case GLSLParser::ISAMPLERBUFFER:
      case GLSLParser::ISAMPLERCUBE:
      case GLSLParser::ISAMPLERCUBEARRAY:
      case GLSLParser::IVEC2:
      case GLSLParser::IVEC3:
      case GLSLParser::IVEC4:
      case GLSLParser::MAT2:
      case GLSLParser::MAT2X2:
      case GLSLParser::MAT2X3:
      case GLSLParser::MAT2X4:
      case GLSLParser::MAT3:
      case GLSLParser::MAT3X2:
      case GLSLParser::MAT3X3:
      case GLSLParser::MAT3X4:
      case GLSLParser::MAT4:
      case GLSLParser::MAT4X2:
      case GLSLParser::MAT4X3:
      case GLSLParser::MAT4X4:
      case GLSLParser::SAMPLER1D:
      case GLSLParser::SAMPLER1DARRAY:
      case GLSLParser::SAMPLER1DARRAYSHADOW:
      case GLSLParser::SAMPLER1DSHADOW:
      case GLSLParser::SAMPLER2D:
      case GLSLParser::SAMPLER2DARRAY:
      case GLSLParser::SAMPLER2DARRAYSHADOW:
      case GLSLParser::SAMPLER2DMS:
      case GLSLParser::SAMPLER2DMSARRAY:
      case GLSLParser::SAMPLER2DRECT:
      case GLSLParser::SAMPLER2DRECTSHADOW:
      case GLSLParser::SAMPLER2DSHADOW:
      case GLSLParser::SAMPLER3D:
      case GLSLParser::SAMPLERBUFFER:
      case GLSLParser::SAMPLERCUBE:
      case GLSLParser::SAMPLERCUBEARRAY:
      case GLSLParser::SAMPLERCUBEARRAYSHADOW:
      case GLSLParser::SAMPLERCUBESHADOW:
      case GLSLParser::STRUCT:
      case GLSLParser::TRUE:
      case GLSLParser::UIMAGE1D:
      case GLSLParser::UIMAGE1DARRAY:
      case GLSLParser::UIMAGE2D:
      case GLSLParser::UIMAGE2DARRAY:
      case GLSLParser::UIMAGE2DMS:
      case GLSLParser::UIMAGE2DMSARRAY:
      case GLSLParser::UIMAGE2DRECT:
      case GLSLParser::UIMAGE3D:
      case GLSLParser::UIMAGEBUFFER:
      case GLSLParser::UIMAGECUBE:
      case GLSLParser::UIMAGECUBEARRAY:
      case GLSLParser::UINT:
      case GLSLParser::USAMPLER1D:
      case GLSLParser::USAMPLER1DARRAY:
      case GLSLParser::USAMPLER2D:
      case GLSLParser::USAMPLER2DARRAY:
      case GLSLParser::USAMPLER2DMS:
      case GLSLParser::USAMPLER2DMSARRAY:
      case GLSLParser::USAMPLER2DRECT:
      case GLSLParser::USAMPLER3D:
      case GLSLParser::USAMPLERBUFFER:
      case GLSLParser::USAMPLERCUBE:
      case GLSLParser::USAMPLERCUBEARRAY:
      case GLSLParser::UVEC2:
      case GLSLParser::UVEC3:
      case GLSLParser::UVEC4:
      case GLSLParser::VEC2:
      case GLSLParser::VEC3:
      case GLSLParser::VEC4:
      case GLSLParser::VOID:
      case GLSLParser::LEFT_PAREN:
      case GLSLParser::DOUBLECONSTANT:
      case GLSLParser::FLOATCONSTANT:
      case GLSLParser::INTCONSTANT:
      case GLSLParser::UINTCONSTANT:
      case GLSLParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(223);
        postfix_expression(0);
        break;
      }

      case GLSLParser::INC_OP: {
        enterOuterAlt(_localctx, 2);
        setState(224);
        match(GLSLParser::INC_OP);
        setState(225);
        unary_expression();
        break;
      }

      case GLSLParser::DEC_OP: {
        enterOuterAlt(_localctx, 3);
        setState(226);
        match(GLSLParser::DEC_OP);
        setState(227);
        unary_expression();
        break;
      }

      case GLSLParser::BANG:
      case GLSLParser::DASH:
      case GLSLParser::PLUS:
      case GLSLParser::TILDE: {
        enterOuterAlt(_localctx, 4);
        setState(228);
        unary_operator();
        setState(229);
        unary_expression();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_operatorContext ------------------------------------------------------------------

GLSLParser::Unary_operatorContext::Unary_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Unary_operatorContext::PLUS() {
  return getToken(GLSLParser::PLUS, 0);
}

tree::TerminalNode* GLSLParser::Unary_operatorContext::DASH() {
  return getToken(GLSLParser::DASH, 0);
}

tree::TerminalNode* GLSLParser::Unary_operatorContext::BANG() {
  return getToken(GLSLParser::BANG, 0);
}

tree::TerminalNode* GLSLParser::Unary_operatorContext::TILDE() {
  return getToken(GLSLParser::TILDE, 0);
}


size_t GLSLParser::Unary_operatorContext::getRuleIndex() const {
  return GLSLParser::RuleUnary_operator;
}

void GLSLParser::Unary_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnary_operator(this);
}

void GLSLParser::Unary_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnary_operator(this);
}

GLSLParser::Unary_operatorContext* GLSLParser::unary_operator() {
  Unary_operatorContext *_localctx = _tracker.createInstance<Unary_operatorContext>(_ctx, getState());
  enterRule(_localctx, 20, GLSLParser::RuleUnary_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(233);
    _la = _input->LA(1);
    if (!(((((_la - 208) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 208)) & 274945015825) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_expressionContext ------------------------------------------------------------------

GLSLParser::Assignment_expressionContext::Assignment_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Constant_expressionContext* GLSLParser::Assignment_expressionContext::constant_expression() {
  return getRuleContext<GLSLParser::Constant_expressionContext>(0);
}

GLSLParser::Unary_expressionContext* GLSLParser::Assignment_expressionContext::unary_expression() {
  return getRuleContext<GLSLParser::Unary_expressionContext>(0);
}

GLSLParser::Assignment_operatorContext* GLSLParser::Assignment_expressionContext::assignment_operator() {
  return getRuleContext<GLSLParser::Assignment_operatorContext>(0);
}

GLSLParser::Assignment_expressionContext* GLSLParser::Assignment_expressionContext::assignment_expression() {
  return getRuleContext<GLSLParser::Assignment_expressionContext>(0);
}


size_t GLSLParser::Assignment_expressionContext::getRuleIndex() const {
  return GLSLParser::RuleAssignment_expression;
}

void GLSLParser::Assignment_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_expression(this);
}

void GLSLParser::Assignment_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_expression(this);
}

GLSLParser::Assignment_expressionContext* GLSLParser::assignment_expression() {
  Assignment_expressionContext *_localctx = _tracker.createInstance<Assignment_expressionContext>(_ctx, getState());
  enterRule(_localctx, 22, GLSLParser::RuleAssignment_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(240);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(235);
      constant_expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(236);
      unary_expression();
      setState(237);
      assignment_operator();
      setState(238);
      assignment_expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_operatorContext ------------------------------------------------------------------

GLSLParser::Assignment_operatorContext::Assignment_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Assignment_operatorContext::EQUAL() {
  return getToken(GLSLParser::EQUAL, 0);
}

tree::TerminalNode* GLSLParser::Assignment_operatorContext::MUL_ASSIGN() {
  return getToken(GLSLParser::MUL_ASSIGN, 0);
}

tree::TerminalNode* GLSLParser::Assignment_operatorContext::DIV_ASSIGN() {
  return getToken(GLSLParser::DIV_ASSIGN, 0);
}

tree::TerminalNode* GLSLParser::Assignment_operatorContext::MOD_ASSIGN() {
  return getToken(GLSLParser::MOD_ASSIGN, 0);
}

tree::TerminalNode* GLSLParser::Assignment_operatorContext::ADD_ASSIGN() {
  return getToken(GLSLParser::ADD_ASSIGN, 0);
}

tree::TerminalNode* GLSLParser::Assignment_operatorContext::SUB_ASSIGN() {
  return getToken(GLSLParser::SUB_ASSIGN, 0);
}

tree::TerminalNode* GLSLParser::Assignment_operatorContext::LEFT_ASSIGN() {
  return getToken(GLSLParser::LEFT_ASSIGN, 0);
}

tree::TerminalNode* GLSLParser::Assignment_operatorContext::RIGHT_ASSIGN() {
  return getToken(GLSLParser::RIGHT_ASSIGN, 0);
}

tree::TerminalNode* GLSLParser::Assignment_operatorContext::AND_ASSIGN() {
  return getToken(GLSLParser::AND_ASSIGN, 0);
}

tree::TerminalNode* GLSLParser::Assignment_operatorContext::XOR_ASSIGN() {
  return getToken(GLSLParser::XOR_ASSIGN, 0);
}

tree::TerminalNode* GLSLParser::Assignment_operatorContext::OR_ASSIGN() {
  return getToken(GLSLParser::OR_ASSIGN, 0);
}


size_t GLSLParser::Assignment_operatorContext::getRuleIndex() const {
  return GLSLParser::RuleAssignment_operator;
}

void GLSLParser::Assignment_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_operator(this);
}

void GLSLParser::Assignment_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_operator(this);
}

GLSLParser::Assignment_operatorContext* GLSLParser::assignment_operator() {
  Assignment_operatorContext *_localctx = _tracker.createInstance<Assignment_operatorContext>(_ctx, getState());
  enterRule(_localctx, 24, GLSLParser::RuleAssignment_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(242);
    _la = _input->LA(1);
    if (!(((((_la - 204) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 204)) & 19799958889477) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Binary_expressionContext ------------------------------------------------------------------

GLSLParser::Binary_expressionContext::Binary_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Unary_expressionContext* GLSLParser::Binary_expressionContext::unary_expression() {
  return getRuleContext<GLSLParser::Unary_expressionContext>(0);
}

std::vector<GLSLParser::Binary_expressionContext *> GLSLParser::Binary_expressionContext::binary_expression() {
  return getRuleContexts<GLSLParser::Binary_expressionContext>();
}

GLSLParser::Binary_expressionContext* GLSLParser::Binary_expressionContext::binary_expression(size_t i) {
  return getRuleContext<GLSLParser::Binary_expressionContext>(i);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::STAR() {
  return getToken(GLSLParser::STAR, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::SLASH() {
  return getToken(GLSLParser::SLASH, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::PERCENT() {
  return getToken(GLSLParser::PERCENT, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::PLUS() {
  return getToken(GLSLParser::PLUS, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::DASH() {
  return getToken(GLSLParser::DASH, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::LEFT_OP() {
  return getToken(GLSLParser::LEFT_OP, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::RIGHT_OP() {
  return getToken(GLSLParser::RIGHT_OP, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::LEFT_ANGLE() {
  return getToken(GLSLParser::LEFT_ANGLE, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::RIGHT_ANGLE() {
  return getToken(GLSLParser::RIGHT_ANGLE, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::LE_OP() {
  return getToken(GLSLParser::LE_OP, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::GE_OP() {
  return getToken(GLSLParser::GE_OP, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::EQ_OP() {
  return getToken(GLSLParser::EQ_OP, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::NE_OP() {
  return getToken(GLSLParser::NE_OP, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::AMPERSAND() {
  return getToken(GLSLParser::AMPERSAND, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::CARET() {
  return getToken(GLSLParser::CARET, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::VERTICAL_BAR() {
  return getToken(GLSLParser::VERTICAL_BAR, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::AND_OP() {
  return getToken(GLSLParser::AND_OP, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::XOR_OP() {
  return getToken(GLSLParser::XOR_OP, 0);
}

tree::TerminalNode* GLSLParser::Binary_expressionContext::OR_OP() {
  return getToken(GLSLParser::OR_OP, 0);
}


size_t GLSLParser::Binary_expressionContext::getRuleIndex() const {
  return GLSLParser::RuleBinary_expression;
}

void GLSLParser::Binary_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinary_expression(this);
}

void GLSLParser::Binary_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinary_expression(this);
}


GLSLParser::Binary_expressionContext* GLSLParser::binary_expression() {
   return binary_expression(0);
}

GLSLParser::Binary_expressionContext* GLSLParser::binary_expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  GLSLParser::Binary_expressionContext *_localctx = _tracker.createInstance<Binary_expressionContext>(_ctx, parentState);
  GLSLParser::Binary_expressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 26;
  enterRecursionRule(_localctx, 26, GLSLParser::RuleBinary_expression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(245);
    unary_expression();
    _ctx->stop = _input->LT(-1);
    setState(282);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(280);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Binary_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBinary_expression);
          setState(247);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(248);
          _la = _input->LA(1);
          if (!(((((_la - 233) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 233)) & 3073) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(249);
          binary_expression(12);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Binary_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBinary_expression);
          setState(250);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(251);
          _la = _input->LA(1);
          if (!(_la == GLSLParser::DASH

          || _la == GLSLParser::PLUS)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(252);
          binary_expression(11);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<Binary_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBinary_expression);
          setState(253);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(254);
          _la = _input->LA(1);
          if (!(_la == GLSLParser::LEFT_OP

          || _la == GLSLParser::RIGHT_OP)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(255);
          binary_expression(10);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<Binary_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBinary_expression);
          setState(256);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(257);
          _la = _input->LA(1);
          if (!(((((_la - 218) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 218)) & 262157) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(258);
          binary_expression(9);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<Binary_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBinary_expression);
          setState(259);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(260);
          _la = _input->LA(1);
          if (!(_la == GLSLParser::EQ_OP

          || _la == GLSLParser::NE_OP)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(261);
          binary_expression(8);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<Binary_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBinary_expression);
          setState(262);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(263);
          match(GLSLParser::AMPERSAND);
          setState(264);
          binary_expression(7);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<Binary_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBinary_expression);
          setState(265);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(266);
          match(GLSLParser::CARET);
          setState(267);
          binary_expression(6);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<Binary_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBinary_expression);
          setState(268);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(269);
          match(GLSLParser::VERTICAL_BAR);
          setState(270);
          binary_expression(5);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<Binary_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBinary_expression);
          setState(271);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(272);
          match(GLSLParser::AND_OP);
          setState(273);
          binary_expression(4);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<Binary_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBinary_expression);
          setState(274);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(275);
          match(GLSLParser::XOR_OP);
          setState(276);
          binary_expression(3);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<Binary_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBinary_expression);
          setState(277);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(278);
          match(GLSLParser::OR_OP);
          setState(279);
          binary_expression(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(284);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

GLSLParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Assignment_expressionContext* GLSLParser::ExpressionContext::assignment_expression() {
  return getRuleContext<GLSLParser::Assignment_expressionContext>(0);
}

GLSLParser::ExpressionContext* GLSLParser::ExpressionContext::expression() {
  return getRuleContext<GLSLParser::ExpressionContext>(0);
}

tree::TerminalNode* GLSLParser::ExpressionContext::COMMA() {
  return getToken(GLSLParser::COMMA, 0);
}


size_t GLSLParser::ExpressionContext::getRuleIndex() const {
  return GLSLParser::RuleExpression;
}

void GLSLParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void GLSLParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


GLSLParser::ExpressionContext* GLSLParser::expression() {
   return expression(0);
}

GLSLParser::ExpressionContext* GLSLParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  GLSLParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  GLSLParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 28;
  enterRecursionRule(_localctx, 28, GLSLParser::RuleExpression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(286);
    assignment_expression();
    _ctx->stop = _input->LT(-1);
    setState(293);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleExpression);
        setState(288);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(289);
        match(GLSLParser::COMMA);
        setState(290);
        assignment_expression(); 
      }
      setState(295);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Constant_expressionContext ------------------------------------------------------------------

GLSLParser::Constant_expressionContext::Constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Binary_expressionContext* GLSLParser::Constant_expressionContext::binary_expression() {
  return getRuleContext<GLSLParser::Binary_expressionContext>(0);
}

tree::TerminalNode* GLSLParser::Constant_expressionContext::QUESTION() {
  return getToken(GLSLParser::QUESTION, 0);
}

GLSLParser::ExpressionContext* GLSLParser::Constant_expressionContext::expression() {
  return getRuleContext<GLSLParser::ExpressionContext>(0);
}

tree::TerminalNode* GLSLParser::Constant_expressionContext::COLON() {
  return getToken(GLSLParser::COLON, 0);
}

GLSLParser::Assignment_expressionContext* GLSLParser::Constant_expressionContext::assignment_expression() {
  return getRuleContext<GLSLParser::Assignment_expressionContext>(0);
}


size_t GLSLParser::Constant_expressionContext::getRuleIndex() const {
  return GLSLParser::RuleConstant_expression;
}

void GLSLParser::Constant_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant_expression(this);
}

void GLSLParser::Constant_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant_expression(this);
}

GLSLParser::Constant_expressionContext* GLSLParser::constant_expression() {
  Constant_expressionContext *_localctx = _tracker.createInstance<Constant_expressionContext>(_ctx, getState());
  enterRule(_localctx, 30, GLSLParser::RuleConstant_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(303);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(296);
      binary_expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(297);
      binary_expression(0);
      setState(298);
      match(GLSLParser::QUESTION);
      setState(299);
      expression(0);
      setState(300);
      match(GLSLParser::COLON);
      setState(301);
      assignment_expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationContext ------------------------------------------------------------------

GLSLParser::DeclarationContext::DeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Function_prototypeContext* GLSLParser::DeclarationContext::function_prototype() {
  return getRuleContext<GLSLParser::Function_prototypeContext>(0);
}

tree::TerminalNode* GLSLParser::DeclarationContext::SEMICOLON() {
  return getToken(GLSLParser::SEMICOLON, 0);
}

GLSLParser::Init_declarator_listContext* GLSLParser::DeclarationContext::init_declarator_list() {
  return getRuleContext<GLSLParser::Init_declarator_listContext>(0);
}

tree::TerminalNode* GLSLParser::DeclarationContext::PRECISION() {
  return getToken(GLSLParser::PRECISION, 0);
}

GLSLParser::Precision_qualifierContext* GLSLParser::DeclarationContext::precision_qualifier() {
  return getRuleContext<GLSLParser::Precision_qualifierContext>(0);
}

GLSLParser::Type_specifierContext* GLSLParser::DeclarationContext::type_specifier() {
  return getRuleContext<GLSLParser::Type_specifierContext>(0);
}

GLSLParser::Type_qualifierContext* GLSLParser::DeclarationContext::type_qualifier() {
  return getRuleContext<GLSLParser::Type_qualifierContext>(0);
}

std::vector<tree::TerminalNode *> GLSLParser::DeclarationContext::IDENTIFIER() {
  return getTokens(GLSLParser::IDENTIFIER);
}

tree::TerminalNode* GLSLParser::DeclarationContext::IDENTIFIER(size_t i) {
  return getToken(GLSLParser::IDENTIFIER, i);
}

tree::TerminalNode* GLSLParser::DeclarationContext::LEFT_BRACE() {
  return getToken(GLSLParser::LEFT_BRACE, 0);
}

GLSLParser::Struct_declaration_listContext* GLSLParser::DeclarationContext::struct_declaration_list() {
  return getRuleContext<GLSLParser::Struct_declaration_listContext>(0);
}

tree::TerminalNode* GLSLParser::DeclarationContext::RIGHT_BRACE() {
  return getToken(GLSLParser::RIGHT_BRACE, 0);
}

GLSLParser::Array_specifierContext* GLSLParser::DeclarationContext::array_specifier() {
  return getRuleContext<GLSLParser::Array_specifierContext>(0);
}

GLSLParser::Identifier_listContext* GLSLParser::DeclarationContext::identifier_list() {
  return getRuleContext<GLSLParser::Identifier_listContext>(0);
}


size_t GLSLParser::DeclarationContext::getRuleIndex() const {
  return GLSLParser::RuleDeclaration;
}

void GLSLParser::DeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclaration(this);
}

void GLSLParser::DeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclaration(this);
}

GLSLParser::DeclarationContext* GLSLParser::declaration() {
  DeclarationContext *_localctx = _tracker.createInstance<DeclarationContext>(_ctx, getState());
  enterRule(_localctx, 32, GLSLParser::RuleDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(335);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(305);
      function_prototype();
      setState(306);
      match(GLSLParser::SEMICOLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(308);
      init_declarator_list();
      setState(309);
      match(GLSLParser::SEMICOLON);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(311);
      match(GLSLParser::PRECISION);
      setState(312);
      precision_qualifier();
      setState(313);
      type_specifier();
      setState(314);
      match(GLSLParser::SEMICOLON);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(316);
      type_qualifier();
      setState(317);
      match(GLSLParser::IDENTIFIER);
      setState(318);
      match(GLSLParser::LEFT_BRACE);
      setState(319);
      struct_declaration_list();
      setState(320);
      match(GLSLParser::RIGHT_BRACE);
      setState(325);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GLSLParser::IDENTIFIER) {
        setState(321);
        match(GLSLParser::IDENTIFIER);
        setState(323);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GLSLParser::LEFT_BRACKET) {
          setState(322);
          array_specifier();
        }
      }
      setState(327);
      match(GLSLParser::SEMICOLON);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(329);
      type_qualifier();
      setState(331);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GLSLParser::IDENTIFIER) {
        setState(330);
        identifier_list();
      }
      setState(333);
      match(GLSLParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Identifier_listContext ------------------------------------------------------------------

GLSLParser::Identifier_listContext::Identifier_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> GLSLParser::Identifier_listContext::IDENTIFIER() {
  return getTokens(GLSLParser::IDENTIFIER);
}

tree::TerminalNode* GLSLParser::Identifier_listContext::IDENTIFIER(size_t i) {
  return getToken(GLSLParser::IDENTIFIER, i);
}

std::vector<tree::TerminalNode *> GLSLParser::Identifier_listContext::COMMA() {
  return getTokens(GLSLParser::COMMA);
}

tree::TerminalNode* GLSLParser::Identifier_listContext::COMMA(size_t i) {
  return getToken(GLSLParser::COMMA, i);
}


size_t GLSLParser::Identifier_listContext::getRuleIndex() const {
  return GLSLParser::RuleIdentifier_list;
}

void GLSLParser::Identifier_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier_list(this);
}

void GLSLParser::Identifier_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier_list(this);
}

GLSLParser::Identifier_listContext* GLSLParser::identifier_list() {
  Identifier_listContext *_localctx = _tracker.createInstance<Identifier_listContext>(_ctx, getState());
  enterRule(_localctx, 34, GLSLParser::RuleIdentifier_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(337);
    match(GLSLParser::IDENTIFIER);
    setState(342);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GLSLParser::COMMA) {
      setState(338);
      match(GLSLParser::COMMA);
      setState(339);
      match(GLSLParser::IDENTIFIER);
      setState(344);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_prototypeContext ------------------------------------------------------------------

GLSLParser::Function_prototypeContext::Function_prototypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Fully_specified_typeContext* GLSLParser::Function_prototypeContext::fully_specified_type() {
  return getRuleContext<GLSLParser::Fully_specified_typeContext>(0);
}

tree::TerminalNode* GLSLParser::Function_prototypeContext::IDENTIFIER() {
  return getToken(GLSLParser::IDENTIFIER, 0);
}

tree::TerminalNode* GLSLParser::Function_prototypeContext::LEFT_PAREN() {
  return getToken(GLSLParser::LEFT_PAREN, 0);
}

tree::TerminalNode* GLSLParser::Function_prototypeContext::RIGHT_PAREN() {
  return getToken(GLSLParser::RIGHT_PAREN, 0);
}

GLSLParser::Function_parametersContext* GLSLParser::Function_prototypeContext::function_parameters() {
  return getRuleContext<GLSLParser::Function_parametersContext>(0);
}


size_t GLSLParser::Function_prototypeContext::getRuleIndex() const {
  return GLSLParser::RuleFunction_prototype;
}

void GLSLParser::Function_prototypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_prototype(this);
}

void GLSLParser::Function_prototypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_prototype(this);
}

GLSLParser::Function_prototypeContext* GLSLParser::function_prototype() {
  Function_prototypeContext *_localctx = _tracker.createInstance<Function_prototypeContext>(_ctx, getState());
  enterRule(_localctx, 36, GLSLParser::RuleFunction_prototype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(345);
    fully_specified_type();
    setState(346);
    match(GLSLParser::IDENTIFIER);
    setState(347);
    match(GLSLParser::LEFT_PAREN);
    setState(349);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -713233064466) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -11540474112237569) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 4503599358955263) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & 1535) != 0) || _la == GLSLParser::IDENTIFIER) {
      setState(348);
      function_parameters();
    }
    setState(351);
    match(GLSLParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_parametersContext ------------------------------------------------------------------

GLSLParser::Function_parametersContext::Function_parametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GLSLParser::Parameter_declarationContext *> GLSLParser::Function_parametersContext::parameter_declaration() {
  return getRuleContexts<GLSLParser::Parameter_declarationContext>();
}

GLSLParser::Parameter_declarationContext* GLSLParser::Function_parametersContext::parameter_declaration(size_t i) {
  return getRuleContext<GLSLParser::Parameter_declarationContext>(i);
}

std::vector<tree::TerminalNode *> GLSLParser::Function_parametersContext::COMMA() {
  return getTokens(GLSLParser::COMMA);
}

tree::TerminalNode* GLSLParser::Function_parametersContext::COMMA(size_t i) {
  return getToken(GLSLParser::COMMA, i);
}


size_t GLSLParser::Function_parametersContext::getRuleIndex() const {
  return GLSLParser::RuleFunction_parameters;
}

void GLSLParser::Function_parametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_parameters(this);
}

void GLSLParser::Function_parametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_parameters(this);
}

GLSLParser::Function_parametersContext* GLSLParser::function_parameters() {
  Function_parametersContext *_localctx = _tracker.createInstance<Function_parametersContext>(_ctx, getState());
  enterRule(_localctx, 38, GLSLParser::RuleFunction_parameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(353);
    parameter_declaration();
    setState(358);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GLSLParser::COMMA) {
      setState(354);
      match(GLSLParser::COMMA);
      setState(355);
      parameter_declaration();
      setState(360);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_declaratorContext ------------------------------------------------------------------

GLSLParser::Parameter_declaratorContext::Parameter_declaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Type_specifierContext* GLSLParser::Parameter_declaratorContext::type_specifier() {
  return getRuleContext<GLSLParser::Type_specifierContext>(0);
}

tree::TerminalNode* GLSLParser::Parameter_declaratorContext::IDENTIFIER() {
  return getToken(GLSLParser::IDENTIFIER, 0);
}

GLSLParser::Array_specifierContext* GLSLParser::Parameter_declaratorContext::array_specifier() {
  return getRuleContext<GLSLParser::Array_specifierContext>(0);
}


size_t GLSLParser::Parameter_declaratorContext::getRuleIndex() const {
  return GLSLParser::RuleParameter_declarator;
}

void GLSLParser::Parameter_declaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_declarator(this);
}

void GLSLParser::Parameter_declaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_declarator(this);
}

GLSLParser::Parameter_declaratorContext* GLSLParser::parameter_declarator() {
  Parameter_declaratorContext *_localctx = _tracker.createInstance<Parameter_declaratorContext>(_ctx, getState());
  enterRule(_localctx, 40, GLSLParser::RuleParameter_declarator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(361);
    type_specifier();
    setState(362);
    match(GLSLParser::IDENTIFIER);
    setState(364);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GLSLParser::LEFT_BRACKET) {
      setState(363);
      array_specifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_declarationContext ------------------------------------------------------------------

GLSLParser::Parameter_declarationContext::Parameter_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Type_qualifierContext* GLSLParser::Parameter_declarationContext::type_qualifier() {
  return getRuleContext<GLSLParser::Type_qualifierContext>(0);
}

GLSLParser::Parameter_declaratorContext* GLSLParser::Parameter_declarationContext::parameter_declarator() {
  return getRuleContext<GLSLParser::Parameter_declaratorContext>(0);
}

GLSLParser::Parameter_type_specifierContext* GLSLParser::Parameter_declarationContext::parameter_type_specifier() {
  return getRuleContext<GLSLParser::Parameter_type_specifierContext>(0);
}


size_t GLSLParser::Parameter_declarationContext::getRuleIndex() const {
  return GLSLParser::RuleParameter_declaration;
}

void GLSLParser::Parameter_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_declaration(this);
}

void GLSLParser::Parameter_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_declaration(this);
}

GLSLParser::Parameter_declarationContext* GLSLParser::parameter_declaration() {
  Parameter_declarationContext *_localctx = _tracker.createInstance<Parameter_declarationContext>(_ctx, getState());
  enterRule(_localctx, 42, GLSLParser::RuleParameter_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(373);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(366);
      type_qualifier();
      setState(369);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx)) {
      case 1: {
        setState(367);
        parameter_declarator();
        break;
      }

      case 2: {
        setState(368);
        parameter_type_specifier();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(371);
      parameter_declarator();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(372);
      parameter_type_specifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_type_specifierContext ------------------------------------------------------------------

GLSLParser::Parameter_type_specifierContext::Parameter_type_specifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Type_specifierContext* GLSLParser::Parameter_type_specifierContext::type_specifier() {
  return getRuleContext<GLSLParser::Type_specifierContext>(0);
}


size_t GLSLParser::Parameter_type_specifierContext::getRuleIndex() const {
  return GLSLParser::RuleParameter_type_specifier;
}

void GLSLParser::Parameter_type_specifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter_type_specifier(this);
}

void GLSLParser::Parameter_type_specifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter_type_specifier(this);
}

GLSLParser::Parameter_type_specifierContext* GLSLParser::parameter_type_specifier() {
  Parameter_type_specifierContext *_localctx = _tracker.createInstance<Parameter_type_specifierContext>(_ctx, getState());
  enterRule(_localctx, 44, GLSLParser::RuleParameter_type_specifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(375);
    type_specifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Init_declarator_listContext ------------------------------------------------------------------

GLSLParser::Init_declarator_listContext::Init_declarator_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Single_declarationContext* GLSLParser::Init_declarator_listContext::single_declaration() {
  return getRuleContext<GLSLParser::Single_declarationContext>(0);
}

std::vector<tree::TerminalNode *> GLSLParser::Init_declarator_listContext::COMMA() {
  return getTokens(GLSLParser::COMMA);
}

tree::TerminalNode* GLSLParser::Init_declarator_listContext::COMMA(size_t i) {
  return getToken(GLSLParser::COMMA, i);
}

std::vector<GLSLParser::Typeless_declarationContext *> GLSLParser::Init_declarator_listContext::typeless_declaration() {
  return getRuleContexts<GLSLParser::Typeless_declarationContext>();
}

GLSLParser::Typeless_declarationContext* GLSLParser::Init_declarator_listContext::typeless_declaration(size_t i) {
  return getRuleContext<GLSLParser::Typeless_declarationContext>(i);
}


size_t GLSLParser::Init_declarator_listContext::getRuleIndex() const {
  return GLSLParser::RuleInit_declarator_list;
}

void GLSLParser::Init_declarator_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInit_declarator_list(this);
}

void GLSLParser::Init_declarator_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInit_declarator_list(this);
}

GLSLParser::Init_declarator_listContext* GLSLParser::init_declarator_list() {
  Init_declarator_listContext *_localctx = _tracker.createInstance<Init_declarator_listContext>(_ctx, getState());
  enterRule(_localctx, 46, GLSLParser::RuleInit_declarator_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(377);
    single_declaration();
    setState(382);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GLSLParser::COMMA) {
      setState(378);
      match(GLSLParser::COMMA);
      setState(379);
      typeless_declaration();
      setState(384);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Single_declarationContext ------------------------------------------------------------------

GLSLParser::Single_declarationContext::Single_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Fully_specified_typeContext* GLSLParser::Single_declarationContext::fully_specified_type() {
  return getRuleContext<GLSLParser::Fully_specified_typeContext>(0);
}

GLSLParser::Typeless_declarationContext* GLSLParser::Single_declarationContext::typeless_declaration() {
  return getRuleContext<GLSLParser::Typeless_declarationContext>(0);
}


size_t GLSLParser::Single_declarationContext::getRuleIndex() const {
  return GLSLParser::RuleSingle_declaration;
}

void GLSLParser::Single_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingle_declaration(this);
}

void GLSLParser::Single_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingle_declaration(this);
}

GLSLParser::Single_declarationContext* GLSLParser::single_declaration() {
  Single_declarationContext *_localctx = _tracker.createInstance<Single_declarationContext>(_ctx, getState());
  enterRule(_localctx, 48, GLSLParser::RuleSingle_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(385);
    fully_specified_type();
    setState(387);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GLSLParser::IDENTIFIER) {
      setState(386);
      typeless_declaration();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Typeless_declarationContext ------------------------------------------------------------------

GLSLParser::Typeless_declarationContext::Typeless_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Typeless_declarationContext::IDENTIFIER() {
  return getToken(GLSLParser::IDENTIFIER, 0);
}

GLSLParser::Array_specifierContext* GLSLParser::Typeless_declarationContext::array_specifier() {
  return getRuleContext<GLSLParser::Array_specifierContext>(0);
}

tree::TerminalNode* GLSLParser::Typeless_declarationContext::EQUAL() {
  return getToken(GLSLParser::EQUAL, 0);
}

GLSLParser::InitializerContext* GLSLParser::Typeless_declarationContext::initializer() {
  return getRuleContext<GLSLParser::InitializerContext>(0);
}


size_t GLSLParser::Typeless_declarationContext::getRuleIndex() const {
  return GLSLParser::RuleTypeless_declaration;
}

void GLSLParser::Typeless_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeless_declaration(this);
}

void GLSLParser::Typeless_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeless_declaration(this);
}

GLSLParser::Typeless_declarationContext* GLSLParser::typeless_declaration() {
  Typeless_declarationContext *_localctx = _tracker.createInstance<Typeless_declarationContext>(_ctx, getState());
  enterRule(_localctx, 50, GLSLParser::RuleTypeless_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(389);
    match(GLSLParser::IDENTIFIER);
    setState(391);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GLSLParser::LEFT_BRACKET) {
      setState(390);
      array_specifier();
    }
    setState(395);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GLSLParser::EQUAL) {
      setState(393);
      match(GLSLParser::EQUAL);
      setState(394);
      initializer();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fully_specified_typeContext ------------------------------------------------------------------

GLSLParser::Fully_specified_typeContext::Fully_specified_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Type_specifierContext* GLSLParser::Fully_specified_typeContext::type_specifier() {
  return getRuleContext<GLSLParser::Type_specifierContext>(0);
}

GLSLParser::Type_qualifierContext* GLSLParser::Fully_specified_typeContext::type_qualifier() {
  return getRuleContext<GLSLParser::Type_qualifierContext>(0);
}


size_t GLSLParser::Fully_specified_typeContext::getRuleIndex() const {
  return GLSLParser::RuleFully_specified_type;
}

void GLSLParser::Fully_specified_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFully_specified_type(this);
}

void GLSLParser::Fully_specified_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFully_specified_type(this);
}

GLSLParser::Fully_specified_typeContext* GLSLParser::fully_specified_type() {
  Fully_specified_typeContext *_localctx = _tracker.createInstance<Fully_specified_typeContext>(_ctx, getState());
  enterRule(_localctx, 52, GLSLParser::RuleFully_specified_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(401);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GLSLParser::ATOMIC_UINT:
      case GLSLParser::BOOL:
      case GLSLParser::BVEC2:
      case GLSLParser::BVEC3:
      case GLSLParser::BVEC4:
      case GLSLParser::DMAT2:
      case GLSLParser::DMAT2X2:
      case GLSLParser::DMAT2X3:
      case GLSLParser::DMAT2X4:
      case GLSLParser::DMAT3:
      case GLSLParser::DMAT3X2:
      case GLSLParser::DMAT3X3:
      case GLSLParser::DMAT3X4:
      case GLSLParser::DMAT4:
      case GLSLParser::DMAT4X2:
      case GLSLParser::DMAT4X3:
      case GLSLParser::DMAT4X4:
      case GLSLParser::DOUBLE:
      case GLSLParser::DVEC2:
      case GLSLParser::DVEC3:
      case GLSLParser::DVEC4:
      case GLSLParser::FLOAT:
      case GLSLParser::IIMAGE1D:
      case GLSLParser::IIMAGE1DARRAY:
      case GLSLParser::IIMAGE2D:
      case GLSLParser::IIMAGE2DARRAY:
      case GLSLParser::IIMAGE2DMS:
      case GLSLParser::IIMAGE2DMSARRAY:
      case GLSLParser::IIMAGE2DRECT:
      case GLSLParser::IIMAGE3D:
      case GLSLParser::IIMAGEBUFFER:
      case GLSLParser::IIMAGECUBE:
      case GLSLParser::IIMAGECUBEARRAY:
      case GLSLParser::IMAGE1D:
      case GLSLParser::IMAGE1DARRAY:
      case GLSLParser::IMAGE2D:
      case GLSLParser::IMAGE2DARRAY:
      case GLSLParser::IMAGE2DMS:
      case GLSLParser::IMAGE2DMSARRAY:
      case GLSLParser::IMAGE2DRECT:
      case GLSLParser::IMAGE3D:
      case GLSLParser::IMAGEBUFFER:
      case GLSLParser::IMAGECUBE:
      case GLSLParser::IMAGECUBEARRAY:
      case GLSLParser::INT:
      case GLSLParser::ISAMPLER1D:
      case GLSLParser::ISAMPLER1DARRAY:
      case GLSLParser::ISAMPLER2D:
      case GLSLParser::ISAMPLER2DARRAY:
      case GLSLParser::ISAMPLER2DMS:
      case GLSLParser::ISAMPLER2DMSARRAY:
      case GLSLParser::ISAMPLER2DRECT:
      case GLSLParser::ISAMPLER3D:
      case GLSLParser::ISAMPLERBUFFER:
      case GLSLParser::ISAMPLERCUBE:
      case GLSLParser::ISAMPLERCUBEARRAY:
      case GLSLParser::IVEC2:
      case GLSLParser::IVEC3:
      case GLSLParser::IVEC4:
      case GLSLParser::MAT2:
      case GLSLParser::MAT2X2:
      case GLSLParser::MAT2X3:
      case GLSLParser::MAT2X4:
      case GLSLParser::MAT3:
      case GLSLParser::MAT3X2:
      case GLSLParser::MAT3X3:
      case GLSLParser::MAT3X4:
      case GLSLParser::MAT4:
      case GLSLParser::MAT4X2:
      case GLSLParser::MAT4X3:
      case GLSLParser::MAT4X4:
      case GLSLParser::SAMPLER1D:
      case GLSLParser::SAMPLER1DARRAY:
      case GLSLParser::SAMPLER1DARRAYSHADOW:
      case GLSLParser::SAMPLER1DSHADOW:
      case GLSLParser::SAMPLER2D:
      case GLSLParser::SAMPLER2DARRAY:
      case GLSLParser::SAMPLER2DARRAYSHADOW:
      case GLSLParser::SAMPLER2DMS:
      case GLSLParser::SAMPLER2DMSARRAY:
      case GLSLParser::SAMPLER2DRECT:
      case GLSLParser::SAMPLER2DRECTSHADOW:
      case GLSLParser::SAMPLER2DSHADOW:
      case GLSLParser::SAMPLER3D:
      case GLSLParser::SAMPLERBUFFER:
      case GLSLParser::SAMPLERCUBE:
      case GLSLParser::SAMPLERCUBEARRAY:
      case GLSLParser::SAMPLERCUBEARRAYSHADOW:
      case GLSLParser::SAMPLERCUBESHADOW:
      case GLSLParser::STRUCT:
      case GLSLParser::UIMAGE1D:
      case GLSLParser::UIMAGE1DARRAY:
      case GLSLParser::UIMAGE2D:
      case GLSLParser::UIMAGE2DARRAY:
      case GLSLParser::UIMAGE2DMS:
      case GLSLParser::UIMAGE2DMSARRAY:
      case GLSLParser::UIMAGE2DRECT:
      case GLSLParser::UIMAGE3D:
      case GLSLParser::UIMAGEBUFFER:
      case GLSLParser::UIMAGECUBE:
      case GLSLParser::UIMAGECUBEARRAY:
      case GLSLParser::UINT:
      case GLSLParser::USAMPLER1D:
      case GLSLParser::USAMPLER1DARRAY:
      case GLSLParser::USAMPLER2D:
      case GLSLParser::USAMPLER2DARRAY:
      case GLSLParser::USAMPLER2DMS:
      case GLSLParser::USAMPLER2DMSARRAY:
      case GLSLParser::USAMPLER2DRECT:
      case GLSLParser::USAMPLER3D:
      case GLSLParser::USAMPLERBUFFER:
      case GLSLParser::USAMPLERCUBE:
      case GLSLParser::USAMPLERCUBEARRAY:
      case GLSLParser::UVEC2:
      case GLSLParser::UVEC3:
      case GLSLParser::UVEC4:
      case GLSLParser::VEC2:
      case GLSLParser::VEC3:
      case GLSLParser::VEC4:
      case GLSLParser::VOID:
      case GLSLParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(397);
        type_specifier();
        break;
      }

      case GLSLParser::ATTRIBUTE:
      case GLSLParser::BUFFER:
      case GLSLParser::CENTROID:
      case GLSLParser::COHERENT:
      case GLSLParser::CONST:
      case GLSLParser::FLAT:
      case GLSLParser::HIGHP:
      case GLSLParser::IN:
      case GLSLParser::INOUT:
      case GLSLParser::INVARIANT:
      case GLSLParser::LAYOUT:
      case GLSLParser::LOWP:
      case GLSLParser::MEDIUMP:
      case GLSLParser::NOPERSPECTIVE:
      case GLSLParser::OUT:
      case GLSLParser::PATCH:
      case GLSLParser::PRECISE:
      case GLSLParser::READONLY:
      case GLSLParser::RESTRICT:
      case GLSLParser::SAMPLE:
      case GLSLParser::SHARED:
      case GLSLParser::SMOOTH:
      case GLSLParser::SUBROUTINE:
      case GLSLParser::UNIFORM:
      case GLSLParser::VARYING:
      case GLSLParser::VOLATILE:
      case GLSLParser::WRITEONLY: {
        enterOuterAlt(_localctx, 2);
        setState(398);
        type_qualifier();
        setState(399);
        type_specifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Invariant_qualifierContext ------------------------------------------------------------------

GLSLParser::Invariant_qualifierContext::Invariant_qualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Invariant_qualifierContext::INVARIANT() {
  return getToken(GLSLParser::INVARIANT, 0);
}


size_t GLSLParser::Invariant_qualifierContext::getRuleIndex() const {
  return GLSLParser::RuleInvariant_qualifier;
}

void GLSLParser::Invariant_qualifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInvariant_qualifier(this);
}

void GLSLParser::Invariant_qualifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInvariant_qualifier(this);
}

GLSLParser::Invariant_qualifierContext* GLSLParser::invariant_qualifier() {
  Invariant_qualifierContext *_localctx = _tracker.createInstance<Invariant_qualifierContext>(_ctx, getState());
  enterRule(_localctx, 54, GLSLParser::RuleInvariant_qualifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(403);
    match(GLSLParser::INVARIANT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Interpolation_qualifierContext ------------------------------------------------------------------

GLSLParser::Interpolation_qualifierContext::Interpolation_qualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Interpolation_qualifierContext::SMOOTH() {
  return getToken(GLSLParser::SMOOTH, 0);
}

tree::TerminalNode* GLSLParser::Interpolation_qualifierContext::FLAT() {
  return getToken(GLSLParser::FLAT, 0);
}

tree::TerminalNode* GLSLParser::Interpolation_qualifierContext::NOPERSPECTIVE() {
  return getToken(GLSLParser::NOPERSPECTIVE, 0);
}


size_t GLSLParser::Interpolation_qualifierContext::getRuleIndex() const {
  return GLSLParser::RuleInterpolation_qualifier;
}

void GLSLParser::Interpolation_qualifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterpolation_qualifier(this);
}

void GLSLParser::Interpolation_qualifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterpolation_qualifier(this);
}

GLSLParser::Interpolation_qualifierContext* GLSLParser::interpolation_qualifier() {
  Interpolation_qualifierContext *_localctx = _tracker.createInstance<Interpolation_qualifierContext>(_ctx, getState());
  enterRule(_localctx, 56, GLSLParser::RuleInterpolation_qualifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(405);
    _la = _input->LA(1);
    if (!(_la == GLSLParser::FLAT || _la == GLSLParser::NOPERSPECTIVE

    || _la == GLSLParser::SMOOTH)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Layout_qualifierContext ------------------------------------------------------------------

GLSLParser::Layout_qualifierContext::Layout_qualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Layout_qualifierContext::LAYOUT() {
  return getToken(GLSLParser::LAYOUT, 0);
}

tree::TerminalNode* GLSLParser::Layout_qualifierContext::LEFT_PAREN() {
  return getToken(GLSLParser::LEFT_PAREN, 0);
}

GLSLParser::Layout_qualifier_id_listContext* GLSLParser::Layout_qualifierContext::layout_qualifier_id_list() {
  return getRuleContext<GLSLParser::Layout_qualifier_id_listContext>(0);
}

tree::TerminalNode* GLSLParser::Layout_qualifierContext::RIGHT_PAREN() {
  return getToken(GLSLParser::RIGHT_PAREN, 0);
}


size_t GLSLParser::Layout_qualifierContext::getRuleIndex() const {
  return GLSLParser::RuleLayout_qualifier;
}

void GLSLParser::Layout_qualifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLayout_qualifier(this);
}

void GLSLParser::Layout_qualifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLayout_qualifier(this);
}

GLSLParser::Layout_qualifierContext* GLSLParser::layout_qualifier() {
  Layout_qualifierContext *_localctx = _tracker.createInstance<Layout_qualifierContext>(_ctx, getState());
  enterRule(_localctx, 58, GLSLParser::RuleLayout_qualifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(407);
    match(GLSLParser::LAYOUT);
    setState(408);
    match(GLSLParser::LEFT_PAREN);
    setState(409);
    layout_qualifier_id_list();
    setState(410);
    match(GLSLParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Layout_qualifier_id_listContext ------------------------------------------------------------------

GLSLParser::Layout_qualifier_id_listContext::Layout_qualifier_id_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GLSLParser::Layout_qualifier_idContext *> GLSLParser::Layout_qualifier_id_listContext::layout_qualifier_id() {
  return getRuleContexts<GLSLParser::Layout_qualifier_idContext>();
}

GLSLParser::Layout_qualifier_idContext* GLSLParser::Layout_qualifier_id_listContext::layout_qualifier_id(size_t i) {
  return getRuleContext<GLSLParser::Layout_qualifier_idContext>(i);
}

std::vector<tree::TerminalNode *> GLSLParser::Layout_qualifier_id_listContext::COMMA() {
  return getTokens(GLSLParser::COMMA);
}

tree::TerminalNode* GLSLParser::Layout_qualifier_id_listContext::COMMA(size_t i) {
  return getToken(GLSLParser::COMMA, i);
}


size_t GLSLParser::Layout_qualifier_id_listContext::getRuleIndex() const {
  return GLSLParser::RuleLayout_qualifier_id_list;
}

void GLSLParser::Layout_qualifier_id_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLayout_qualifier_id_list(this);
}

void GLSLParser::Layout_qualifier_id_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLayout_qualifier_id_list(this);
}

GLSLParser::Layout_qualifier_id_listContext* GLSLParser::layout_qualifier_id_list() {
  Layout_qualifier_id_listContext *_localctx = _tracker.createInstance<Layout_qualifier_id_listContext>(_ctx, getState());
  enterRule(_localctx, 60, GLSLParser::RuleLayout_qualifier_id_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(412);
    layout_qualifier_id();
    setState(417);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GLSLParser::COMMA) {
      setState(413);
      match(GLSLParser::COMMA);
      setState(414);
      layout_qualifier_id();
      setState(419);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Layout_qualifier_idContext ------------------------------------------------------------------

GLSLParser::Layout_qualifier_idContext::Layout_qualifier_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Layout_qualifier_idContext::IDENTIFIER() {
  return getToken(GLSLParser::IDENTIFIER, 0);
}

tree::TerminalNode* GLSLParser::Layout_qualifier_idContext::EQUAL() {
  return getToken(GLSLParser::EQUAL, 0);
}

GLSLParser::Constant_expressionContext* GLSLParser::Layout_qualifier_idContext::constant_expression() {
  return getRuleContext<GLSLParser::Constant_expressionContext>(0);
}

tree::TerminalNode* GLSLParser::Layout_qualifier_idContext::SHARED() {
  return getToken(GLSLParser::SHARED, 0);
}


size_t GLSLParser::Layout_qualifier_idContext::getRuleIndex() const {
  return GLSLParser::RuleLayout_qualifier_id;
}

void GLSLParser::Layout_qualifier_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLayout_qualifier_id(this);
}

void GLSLParser::Layout_qualifier_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLayout_qualifier_id(this);
}

GLSLParser::Layout_qualifier_idContext* GLSLParser::layout_qualifier_id() {
  Layout_qualifier_idContext *_localctx = _tracker.createInstance<Layout_qualifier_idContext>(_ctx, getState());
  enterRule(_localctx, 62, GLSLParser::RuleLayout_qualifier_id);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(426);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GLSLParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(420);
        match(GLSLParser::IDENTIFIER);
        setState(423);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GLSLParser::EQUAL) {
          setState(421);
          match(GLSLParser::EQUAL);
          setState(422);
          constant_expression();
        }
        break;
      }

      case GLSLParser::SHARED: {
        enterOuterAlt(_localctx, 2);
        setState(425);
        match(GLSLParser::SHARED);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Precise_qualifierContext ------------------------------------------------------------------

GLSLParser::Precise_qualifierContext::Precise_qualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Precise_qualifierContext::PRECISE() {
  return getToken(GLSLParser::PRECISE, 0);
}


size_t GLSLParser::Precise_qualifierContext::getRuleIndex() const {
  return GLSLParser::RulePrecise_qualifier;
}

void GLSLParser::Precise_qualifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrecise_qualifier(this);
}

void GLSLParser::Precise_qualifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrecise_qualifier(this);
}

GLSLParser::Precise_qualifierContext* GLSLParser::precise_qualifier() {
  Precise_qualifierContext *_localctx = _tracker.createInstance<Precise_qualifierContext>(_ctx, getState());
  enterRule(_localctx, 64, GLSLParser::RulePrecise_qualifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(428);
    match(GLSLParser::PRECISE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_qualifierContext ------------------------------------------------------------------

GLSLParser::Type_qualifierContext::Type_qualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GLSLParser::Single_type_qualifierContext *> GLSLParser::Type_qualifierContext::single_type_qualifier() {
  return getRuleContexts<GLSLParser::Single_type_qualifierContext>();
}

GLSLParser::Single_type_qualifierContext* GLSLParser::Type_qualifierContext::single_type_qualifier(size_t i) {
  return getRuleContext<GLSLParser::Single_type_qualifierContext>(i);
}


size_t GLSLParser::Type_qualifierContext::getRuleIndex() const {
  return GLSLParser::RuleType_qualifier;
}

void GLSLParser::Type_qualifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_qualifier(this);
}

void GLSLParser::Type_qualifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_qualifier(this);
}

GLSLParser::Type_qualifierContext* GLSLParser::type_qualifier() {
  Type_qualifierContext *_localctx = _tracker.createInstance<Type_qualifierContext>(_ctx, getState());
  enterRule(_localctx, 66, GLSLParser::RuleType_qualifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(431); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(430);
      single_type_qualifier();
      setState(433); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 2) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 2)) & -5764607445724821751) != 0) || ((((_la - 93) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 93)) & 615726523596803) != 0) || ((((_la - 168) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 168)) & 43218108417) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Single_type_qualifierContext ------------------------------------------------------------------

GLSLParser::Single_type_qualifierContext::Single_type_qualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Storage_qualifierContext* GLSLParser::Single_type_qualifierContext::storage_qualifier() {
  return getRuleContext<GLSLParser::Storage_qualifierContext>(0);
}

GLSLParser::Layout_qualifierContext* GLSLParser::Single_type_qualifierContext::layout_qualifier() {
  return getRuleContext<GLSLParser::Layout_qualifierContext>(0);
}

GLSLParser::Precision_qualifierContext* GLSLParser::Single_type_qualifierContext::precision_qualifier() {
  return getRuleContext<GLSLParser::Precision_qualifierContext>(0);
}

GLSLParser::Interpolation_qualifierContext* GLSLParser::Single_type_qualifierContext::interpolation_qualifier() {
  return getRuleContext<GLSLParser::Interpolation_qualifierContext>(0);
}

GLSLParser::Invariant_qualifierContext* GLSLParser::Single_type_qualifierContext::invariant_qualifier() {
  return getRuleContext<GLSLParser::Invariant_qualifierContext>(0);
}

GLSLParser::Precise_qualifierContext* GLSLParser::Single_type_qualifierContext::precise_qualifier() {
  return getRuleContext<GLSLParser::Precise_qualifierContext>(0);
}


size_t GLSLParser::Single_type_qualifierContext::getRuleIndex() const {
  return GLSLParser::RuleSingle_type_qualifier;
}

void GLSLParser::Single_type_qualifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingle_type_qualifier(this);
}

void GLSLParser::Single_type_qualifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingle_type_qualifier(this);
}

GLSLParser::Single_type_qualifierContext* GLSLParser::single_type_qualifier() {
  Single_type_qualifierContext *_localctx = _tracker.createInstance<Single_type_qualifierContext>(_ctx, getState());
  enterRule(_localctx, 68, GLSLParser::RuleSingle_type_qualifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(441);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GLSLParser::ATTRIBUTE:
      case GLSLParser::BUFFER:
      case GLSLParser::CENTROID:
      case GLSLParser::COHERENT:
      case GLSLParser::CONST:
      case GLSLParser::IN:
      case GLSLParser::INOUT:
      case GLSLParser::OUT:
      case GLSLParser::PATCH:
      case GLSLParser::READONLY:
      case GLSLParser::RESTRICT:
      case GLSLParser::SAMPLE:
      case GLSLParser::SHARED:
      case GLSLParser::SUBROUTINE:
      case GLSLParser::UNIFORM:
      case GLSLParser::VARYING:
      case GLSLParser::VOLATILE:
      case GLSLParser::WRITEONLY: {
        enterOuterAlt(_localctx, 1);
        setState(435);
        storage_qualifier();
        break;
      }

      case GLSLParser::LAYOUT: {
        enterOuterAlt(_localctx, 2);
        setState(436);
        layout_qualifier();
        break;
      }

      case GLSLParser::HIGHP:
      case GLSLParser::LOWP:
      case GLSLParser::MEDIUMP: {
        enterOuterAlt(_localctx, 3);
        setState(437);
        precision_qualifier();
        break;
      }

      case GLSLParser::FLAT:
      case GLSLParser::NOPERSPECTIVE:
      case GLSLParser::SMOOTH: {
        enterOuterAlt(_localctx, 4);
        setState(438);
        interpolation_qualifier();
        break;
      }

      case GLSLParser::INVARIANT: {
        enterOuterAlt(_localctx, 5);
        setState(439);
        invariant_qualifier();
        break;
      }

      case GLSLParser::PRECISE: {
        enterOuterAlt(_localctx, 6);
        setState(440);
        precise_qualifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Storage_qualifierContext ------------------------------------------------------------------

GLSLParser::Storage_qualifierContext::Storage_qualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::CONST() {
  return getToken(GLSLParser::CONST, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::IN() {
  return getToken(GLSLParser::IN, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::OUT() {
  return getToken(GLSLParser::OUT, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::INOUT() {
  return getToken(GLSLParser::INOUT, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::CENTROID() {
  return getToken(GLSLParser::CENTROID, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::PATCH() {
  return getToken(GLSLParser::PATCH, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::SAMPLE() {
  return getToken(GLSLParser::SAMPLE, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::UNIFORM() {
  return getToken(GLSLParser::UNIFORM, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::BUFFER() {
  return getToken(GLSLParser::BUFFER, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::SHARED() {
  return getToken(GLSLParser::SHARED, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::COHERENT() {
  return getToken(GLSLParser::COHERENT, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::VOLATILE() {
  return getToken(GLSLParser::VOLATILE, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::RESTRICT() {
  return getToken(GLSLParser::RESTRICT, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::READONLY() {
  return getToken(GLSLParser::READONLY, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::WRITEONLY() {
  return getToken(GLSLParser::WRITEONLY, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::SUBROUTINE() {
  return getToken(GLSLParser::SUBROUTINE, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::LEFT_PAREN() {
  return getToken(GLSLParser::LEFT_PAREN, 0);
}

GLSLParser::Type_name_listContext* GLSLParser::Storage_qualifierContext::type_name_list() {
  return getRuleContext<GLSLParser::Type_name_listContext>(0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::RIGHT_PAREN() {
  return getToken(GLSLParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::ATTRIBUTE() {
  return getToken(GLSLParser::ATTRIBUTE, 0);
}

tree::TerminalNode* GLSLParser::Storage_qualifierContext::VARYING() {
  return getToken(GLSLParser::VARYING, 0);
}


size_t GLSLParser::Storage_qualifierContext::getRuleIndex() const {
  return GLSLParser::RuleStorage_qualifier;
}

void GLSLParser::Storage_qualifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStorage_qualifier(this);
}

void GLSLParser::Storage_qualifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStorage_qualifier(this);
}

GLSLParser::Storage_qualifierContext* GLSLParser::storage_qualifier() {
  Storage_qualifierContext *_localctx = _tracker.createInstance<Storage_qualifierContext>(_ctx, getState());
  enterRule(_localctx, 70, GLSLParser::RuleStorage_qualifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(467);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GLSLParser::CONST: {
        enterOuterAlt(_localctx, 1);
        setState(443);
        match(GLSLParser::CONST);
        break;
      }

      case GLSLParser::IN: {
        enterOuterAlt(_localctx, 2);
        setState(444);
        match(GLSLParser::IN);
        break;
      }

      case GLSLParser::OUT: {
        enterOuterAlt(_localctx, 3);
        setState(445);
        match(GLSLParser::OUT);
        break;
      }

      case GLSLParser::INOUT: {
        enterOuterAlt(_localctx, 4);
        setState(446);
        match(GLSLParser::INOUT);
        break;
      }

      case GLSLParser::CENTROID: {
        enterOuterAlt(_localctx, 5);
        setState(447);
        match(GLSLParser::CENTROID);
        break;
      }

      case GLSLParser::PATCH: {
        enterOuterAlt(_localctx, 6);
        setState(448);
        match(GLSLParser::PATCH);
        break;
      }

      case GLSLParser::SAMPLE: {
        enterOuterAlt(_localctx, 7);
        setState(449);
        match(GLSLParser::SAMPLE);
        break;
      }

      case GLSLParser::UNIFORM: {
        enterOuterAlt(_localctx, 8);
        setState(450);
        match(GLSLParser::UNIFORM);
        break;
      }

      case GLSLParser::BUFFER: {
        enterOuterAlt(_localctx, 9);
        setState(451);
        match(GLSLParser::BUFFER);
        break;
      }

      case GLSLParser::SHARED: {
        enterOuterAlt(_localctx, 10);
        setState(452);
        match(GLSLParser::SHARED);
        break;
      }

      case GLSLParser::COHERENT: {
        enterOuterAlt(_localctx, 11);
        setState(453);
        match(GLSLParser::COHERENT);
        break;
      }

      case GLSLParser::VOLATILE: {
        enterOuterAlt(_localctx, 12);
        setState(454);
        match(GLSLParser::VOLATILE);
        break;
      }

      case GLSLParser::RESTRICT: {
        enterOuterAlt(_localctx, 13);
        setState(455);
        match(GLSLParser::RESTRICT);
        break;
      }

      case GLSLParser::READONLY: {
        enterOuterAlt(_localctx, 14);
        setState(456);
        match(GLSLParser::READONLY);
        break;
      }

      case GLSLParser::WRITEONLY: {
        enterOuterAlt(_localctx, 15);
        setState(457);
        match(GLSLParser::WRITEONLY);
        break;
      }

      case GLSLParser::SUBROUTINE: {
        enterOuterAlt(_localctx, 16);
        setState(458);
        match(GLSLParser::SUBROUTINE);
        setState(463);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GLSLParser::LEFT_PAREN) {
          setState(459);
          match(GLSLParser::LEFT_PAREN);
          setState(460);
          type_name_list();
          setState(461);
          match(GLSLParser::RIGHT_PAREN);
        }
        break;
      }

      case GLSLParser::ATTRIBUTE: {
        enterOuterAlt(_localctx, 17);
        setState(465);
        match(GLSLParser::ATTRIBUTE);
        break;
      }

      case GLSLParser::VARYING: {
        enterOuterAlt(_localctx, 18);
        setState(466);
        match(GLSLParser::VARYING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_name_listContext ------------------------------------------------------------------

GLSLParser::Type_name_listContext::Type_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GLSLParser::Type_nameContext *> GLSLParser::Type_name_listContext::type_name() {
  return getRuleContexts<GLSLParser::Type_nameContext>();
}

GLSLParser::Type_nameContext* GLSLParser::Type_name_listContext::type_name(size_t i) {
  return getRuleContext<GLSLParser::Type_nameContext>(i);
}

std::vector<tree::TerminalNode *> GLSLParser::Type_name_listContext::COMMA() {
  return getTokens(GLSLParser::COMMA);
}

tree::TerminalNode* GLSLParser::Type_name_listContext::COMMA(size_t i) {
  return getToken(GLSLParser::COMMA, i);
}


size_t GLSLParser::Type_name_listContext::getRuleIndex() const {
  return GLSLParser::RuleType_name_list;
}

void GLSLParser::Type_name_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_name_list(this);
}

void GLSLParser::Type_name_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_name_list(this);
}

GLSLParser::Type_name_listContext* GLSLParser::type_name_list() {
  Type_name_listContext *_localctx = _tracker.createInstance<Type_name_listContext>(_ctx, getState());
  enterRule(_localctx, 72, GLSLParser::RuleType_name_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(469);
    type_name();
    setState(474);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GLSLParser::COMMA) {
      setState(470);
      match(GLSLParser::COMMA);
      setState(471);
      type_name();
      setState(476);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_nameContext ------------------------------------------------------------------

GLSLParser::Type_nameContext::Type_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Type_nameContext::IDENTIFIER() {
  return getToken(GLSLParser::IDENTIFIER, 0);
}


size_t GLSLParser::Type_nameContext::getRuleIndex() const {
  return GLSLParser::RuleType_name;
}

void GLSLParser::Type_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_name(this);
}

void GLSLParser::Type_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_name(this);
}

GLSLParser::Type_nameContext* GLSLParser::type_name() {
  Type_nameContext *_localctx = _tracker.createInstance<Type_nameContext>(_ctx, getState());
  enterRule(_localctx, 74, GLSLParser::RuleType_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(477);
    match(GLSLParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_specifierContext ------------------------------------------------------------------

GLSLParser::Type_specifierContext::Type_specifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Type_specifier_nonarrayContext* GLSLParser::Type_specifierContext::type_specifier_nonarray() {
  return getRuleContext<GLSLParser::Type_specifier_nonarrayContext>(0);
}

GLSLParser::Array_specifierContext* GLSLParser::Type_specifierContext::array_specifier() {
  return getRuleContext<GLSLParser::Array_specifierContext>(0);
}


size_t GLSLParser::Type_specifierContext::getRuleIndex() const {
  return GLSLParser::RuleType_specifier;
}

void GLSLParser::Type_specifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_specifier(this);
}

void GLSLParser::Type_specifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_specifier(this);
}

GLSLParser::Type_specifierContext* GLSLParser::type_specifier() {
  Type_specifierContext *_localctx = _tracker.createInstance<Type_specifierContext>(_ctx, getState());
  enterRule(_localctx, 76, GLSLParser::RuleType_specifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(479);
    type_specifier_nonarray();
    setState(481);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GLSLParser::LEFT_BRACKET) {
      setState(480);
      array_specifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_specifierContext ------------------------------------------------------------------

GLSLParser::Array_specifierContext::Array_specifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GLSLParser::DimensionContext *> GLSLParser::Array_specifierContext::dimension() {
  return getRuleContexts<GLSLParser::DimensionContext>();
}

GLSLParser::DimensionContext* GLSLParser::Array_specifierContext::dimension(size_t i) {
  return getRuleContext<GLSLParser::DimensionContext>(i);
}


size_t GLSLParser::Array_specifierContext::getRuleIndex() const {
  return GLSLParser::RuleArray_specifier;
}

void GLSLParser::Array_specifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_specifier(this);
}

void GLSLParser::Array_specifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_specifier(this);
}

GLSLParser::Array_specifierContext* GLSLParser::array_specifier() {
  Array_specifierContext *_localctx = _tracker.createInstance<Array_specifierContext>(_ctx, getState());
  enterRule(_localctx, 78, GLSLParser::RuleArray_specifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(484); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(483);
      dimension();
      setState(486); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == GLSLParser::LEFT_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DimensionContext ------------------------------------------------------------------

GLSLParser::DimensionContext::DimensionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::DimensionContext::LEFT_BRACKET() {
  return getToken(GLSLParser::LEFT_BRACKET, 0);
}

tree::TerminalNode* GLSLParser::DimensionContext::RIGHT_BRACKET() {
  return getToken(GLSLParser::RIGHT_BRACKET, 0);
}

GLSLParser::Constant_expressionContext* GLSLParser::DimensionContext::constant_expression() {
  return getRuleContext<GLSLParser::Constant_expressionContext>(0);
}


size_t GLSLParser::DimensionContext::getRuleIndex() const {
  return GLSLParser::RuleDimension;
}

void GLSLParser::DimensionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDimension(this);
}

void GLSLParser::DimensionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDimension(this);
}

GLSLParser::DimensionContext* GLSLParser::dimension() {
  DimensionContext *_localctx = _tracker.createInstance<DimensionContext>(_ctx, getState());
  enterRule(_localctx, 80, GLSLParser::RuleDimension);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(488);
    match(GLSLParser::LEFT_BRACKET);
    setState(490);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 1) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1)) & -6917529530286505755) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & -4501401023543297) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 130)) & -9222246411859393985) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 194)) & -8138003422817533829) != 0)) {
      setState(489);
      constant_expression();
    }
    setState(492);
    match(GLSLParser::RIGHT_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_specifier_nonarrayContext ------------------------------------------------------------------

GLSLParser::Type_specifier_nonarrayContext::Type_specifier_nonarrayContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::VOID() {
  return getToken(GLSLParser::VOID, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::FLOAT() {
  return getToken(GLSLParser::FLOAT, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::DOUBLE() {
  return getToken(GLSLParser::DOUBLE, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::INT() {
  return getToken(GLSLParser::INT, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::UINT() {
  return getToken(GLSLParser::UINT, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::BOOL() {
  return getToken(GLSLParser::BOOL, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::VEC2() {
  return getToken(GLSLParser::VEC2, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::VEC3() {
  return getToken(GLSLParser::VEC3, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::VEC4() {
  return getToken(GLSLParser::VEC4, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::DVEC2() {
  return getToken(GLSLParser::DVEC2, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::DVEC3() {
  return getToken(GLSLParser::DVEC3, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::DVEC4() {
  return getToken(GLSLParser::DVEC4, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::BVEC2() {
  return getToken(GLSLParser::BVEC2, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::BVEC3() {
  return getToken(GLSLParser::BVEC3, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::BVEC4() {
  return getToken(GLSLParser::BVEC4, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IVEC2() {
  return getToken(GLSLParser::IVEC2, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IVEC3() {
  return getToken(GLSLParser::IVEC3, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IVEC4() {
  return getToken(GLSLParser::IVEC4, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::UVEC2() {
  return getToken(GLSLParser::UVEC2, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::UVEC3() {
  return getToken(GLSLParser::UVEC3, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::UVEC4() {
  return getToken(GLSLParser::UVEC4, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::MAT2() {
  return getToken(GLSLParser::MAT2, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::MAT3() {
  return getToken(GLSLParser::MAT3, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::MAT4() {
  return getToken(GLSLParser::MAT4, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::MAT2X2() {
  return getToken(GLSLParser::MAT2X2, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::MAT2X3() {
  return getToken(GLSLParser::MAT2X3, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::MAT2X4() {
  return getToken(GLSLParser::MAT2X4, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::MAT3X2() {
  return getToken(GLSLParser::MAT3X2, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::MAT3X3() {
  return getToken(GLSLParser::MAT3X3, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::MAT3X4() {
  return getToken(GLSLParser::MAT3X4, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::MAT4X2() {
  return getToken(GLSLParser::MAT4X2, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::MAT4X3() {
  return getToken(GLSLParser::MAT4X3, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::MAT4X4() {
  return getToken(GLSLParser::MAT4X4, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::DMAT2() {
  return getToken(GLSLParser::DMAT2, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::DMAT3() {
  return getToken(GLSLParser::DMAT3, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::DMAT4() {
  return getToken(GLSLParser::DMAT4, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::DMAT2X2() {
  return getToken(GLSLParser::DMAT2X2, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::DMAT2X3() {
  return getToken(GLSLParser::DMAT2X3, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::DMAT2X4() {
  return getToken(GLSLParser::DMAT2X4, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::DMAT3X2() {
  return getToken(GLSLParser::DMAT3X2, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::DMAT3X3() {
  return getToken(GLSLParser::DMAT3X3, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::DMAT3X4() {
  return getToken(GLSLParser::DMAT3X4, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::DMAT4X2() {
  return getToken(GLSLParser::DMAT4X2, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::DMAT4X3() {
  return getToken(GLSLParser::DMAT4X3, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::DMAT4X4() {
  return getToken(GLSLParser::DMAT4X4, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::ATOMIC_UINT() {
  return getToken(GLSLParser::ATOMIC_UINT, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLER2D() {
  return getToken(GLSLParser::SAMPLER2D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLER3D() {
  return getToken(GLSLParser::SAMPLER3D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLERCUBE() {
  return getToken(GLSLParser::SAMPLERCUBE, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLER2DSHADOW() {
  return getToken(GLSLParser::SAMPLER2DSHADOW, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLERCUBESHADOW() {
  return getToken(GLSLParser::SAMPLERCUBESHADOW, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLER2DARRAY() {
  return getToken(GLSLParser::SAMPLER2DARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLER2DARRAYSHADOW() {
  return getToken(GLSLParser::SAMPLER2DARRAYSHADOW, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLERCUBEARRAY() {
  return getToken(GLSLParser::SAMPLERCUBEARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLERCUBEARRAYSHADOW() {
  return getToken(GLSLParser::SAMPLERCUBEARRAYSHADOW, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::ISAMPLER2D() {
  return getToken(GLSLParser::ISAMPLER2D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::ISAMPLER3D() {
  return getToken(GLSLParser::ISAMPLER3D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::ISAMPLERCUBE() {
  return getToken(GLSLParser::ISAMPLERCUBE, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::ISAMPLER2DARRAY() {
  return getToken(GLSLParser::ISAMPLER2DARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::ISAMPLERCUBEARRAY() {
  return getToken(GLSLParser::ISAMPLERCUBEARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::USAMPLER2D() {
  return getToken(GLSLParser::USAMPLER2D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::USAMPLER3D() {
  return getToken(GLSLParser::USAMPLER3D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::USAMPLERCUBE() {
  return getToken(GLSLParser::USAMPLERCUBE, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::USAMPLER2DARRAY() {
  return getToken(GLSLParser::USAMPLER2DARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::USAMPLERCUBEARRAY() {
  return getToken(GLSLParser::USAMPLERCUBEARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLER1D() {
  return getToken(GLSLParser::SAMPLER1D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLER1DSHADOW() {
  return getToken(GLSLParser::SAMPLER1DSHADOW, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLER1DARRAY() {
  return getToken(GLSLParser::SAMPLER1DARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLER1DARRAYSHADOW() {
  return getToken(GLSLParser::SAMPLER1DARRAYSHADOW, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::ISAMPLER1D() {
  return getToken(GLSLParser::ISAMPLER1D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::ISAMPLER1DARRAY() {
  return getToken(GLSLParser::ISAMPLER1DARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::USAMPLER1D() {
  return getToken(GLSLParser::USAMPLER1D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::USAMPLER1DARRAY() {
  return getToken(GLSLParser::USAMPLER1DARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLER2DRECT() {
  return getToken(GLSLParser::SAMPLER2DRECT, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLER2DRECTSHADOW() {
  return getToken(GLSLParser::SAMPLER2DRECTSHADOW, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::ISAMPLER2DRECT() {
  return getToken(GLSLParser::ISAMPLER2DRECT, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::USAMPLER2DRECT() {
  return getToken(GLSLParser::USAMPLER2DRECT, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLERBUFFER() {
  return getToken(GLSLParser::SAMPLERBUFFER, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::ISAMPLERBUFFER() {
  return getToken(GLSLParser::ISAMPLERBUFFER, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::USAMPLERBUFFER() {
  return getToken(GLSLParser::USAMPLERBUFFER, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLER2DMS() {
  return getToken(GLSLParser::SAMPLER2DMS, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::ISAMPLER2DMS() {
  return getToken(GLSLParser::ISAMPLER2DMS, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::USAMPLER2DMS() {
  return getToken(GLSLParser::USAMPLER2DMS, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::SAMPLER2DMSARRAY() {
  return getToken(GLSLParser::SAMPLER2DMSARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::ISAMPLER2DMSARRAY() {
  return getToken(GLSLParser::ISAMPLER2DMSARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::USAMPLER2DMSARRAY() {
  return getToken(GLSLParser::USAMPLER2DMSARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IMAGE2D() {
  return getToken(GLSLParser::IMAGE2D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IIMAGE2D() {
  return getToken(GLSLParser::IIMAGE2D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::UIMAGE2D() {
  return getToken(GLSLParser::UIMAGE2D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IMAGE3D() {
  return getToken(GLSLParser::IMAGE3D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IIMAGE3D() {
  return getToken(GLSLParser::IIMAGE3D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::UIMAGE3D() {
  return getToken(GLSLParser::UIMAGE3D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IMAGECUBE() {
  return getToken(GLSLParser::IMAGECUBE, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IIMAGECUBE() {
  return getToken(GLSLParser::IIMAGECUBE, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::UIMAGECUBE() {
  return getToken(GLSLParser::UIMAGECUBE, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IMAGEBUFFER() {
  return getToken(GLSLParser::IMAGEBUFFER, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IIMAGEBUFFER() {
  return getToken(GLSLParser::IIMAGEBUFFER, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::UIMAGEBUFFER() {
  return getToken(GLSLParser::UIMAGEBUFFER, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IMAGE1D() {
  return getToken(GLSLParser::IMAGE1D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IIMAGE1D() {
  return getToken(GLSLParser::IIMAGE1D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::UIMAGE1D() {
  return getToken(GLSLParser::UIMAGE1D, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IMAGE1DARRAY() {
  return getToken(GLSLParser::IMAGE1DARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IIMAGE1DARRAY() {
  return getToken(GLSLParser::IIMAGE1DARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::UIMAGE1DARRAY() {
  return getToken(GLSLParser::UIMAGE1DARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IMAGE2DRECT() {
  return getToken(GLSLParser::IMAGE2DRECT, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IIMAGE2DRECT() {
  return getToken(GLSLParser::IIMAGE2DRECT, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::UIMAGE2DRECT() {
  return getToken(GLSLParser::UIMAGE2DRECT, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IMAGE2DARRAY() {
  return getToken(GLSLParser::IMAGE2DARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IIMAGE2DARRAY() {
  return getToken(GLSLParser::IIMAGE2DARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::UIMAGE2DARRAY() {
  return getToken(GLSLParser::UIMAGE2DARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IMAGECUBEARRAY() {
  return getToken(GLSLParser::IMAGECUBEARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IIMAGECUBEARRAY() {
  return getToken(GLSLParser::IIMAGECUBEARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::UIMAGECUBEARRAY() {
  return getToken(GLSLParser::UIMAGECUBEARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IMAGE2DMS() {
  return getToken(GLSLParser::IMAGE2DMS, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IIMAGE2DMS() {
  return getToken(GLSLParser::IIMAGE2DMS, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::UIMAGE2DMS() {
  return getToken(GLSLParser::UIMAGE2DMS, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IMAGE2DMSARRAY() {
  return getToken(GLSLParser::IMAGE2DMSARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::IIMAGE2DMSARRAY() {
  return getToken(GLSLParser::IIMAGE2DMSARRAY, 0);
}

tree::TerminalNode* GLSLParser::Type_specifier_nonarrayContext::UIMAGE2DMSARRAY() {
  return getToken(GLSLParser::UIMAGE2DMSARRAY, 0);
}

GLSLParser::Struct_specifierContext* GLSLParser::Type_specifier_nonarrayContext::struct_specifier() {
  return getRuleContext<GLSLParser::Struct_specifierContext>(0);
}

GLSLParser::Type_nameContext* GLSLParser::Type_specifier_nonarrayContext::type_name() {
  return getRuleContext<GLSLParser::Type_nameContext>(0);
}


size_t GLSLParser::Type_specifier_nonarrayContext::getRuleIndex() const {
  return GLSLParser::RuleType_specifier_nonarray;
}

void GLSLParser::Type_specifier_nonarrayContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_specifier_nonarray(this);
}

void GLSLParser::Type_specifier_nonarrayContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_specifier_nonarray(this);
}

GLSLParser::Type_specifier_nonarrayContext* GLSLParser::type_specifier_nonarray() {
  Type_specifier_nonarrayContext *_localctx = _tracker.createInstance<Type_specifier_nonarrayContext>(_ctx, getState());
  enterRule(_localctx, 82, GLSLParser::RuleType_specifier_nonarray);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(615);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GLSLParser::VOID: {
        enterOuterAlt(_localctx, 1);
        setState(494);
        match(GLSLParser::VOID);
        break;
      }

      case GLSLParser::FLOAT: {
        enterOuterAlt(_localctx, 2);
        setState(495);
        match(GLSLParser::FLOAT);
        break;
      }

      case GLSLParser::DOUBLE: {
        enterOuterAlt(_localctx, 3);
        setState(496);
        match(GLSLParser::DOUBLE);
        break;
      }

      case GLSLParser::INT: {
        enterOuterAlt(_localctx, 4);
        setState(497);
        match(GLSLParser::INT);
        break;
      }

      case GLSLParser::UINT: {
        enterOuterAlt(_localctx, 5);
        setState(498);
        match(GLSLParser::UINT);
        break;
      }

      case GLSLParser::BOOL: {
        enterOuterAlt(_localctx, 6);
        setState(499);
        match(GLSLParser::BOOL);
        break;
      }

      case GLSLParser::VEC2: {
        enterOuterAlt(_localctx, 7);
        setState(500);
        match(GLSLParser::VEC2);
        break;
      }

      case GLSLParser::VEC3: {
        enterOuterAlt(_localctx, 8);
        setState(501);
        match(GLSLParser::VEC3);
        break;
      }

      case GLSLParser::VEC4: {
        enterOuterAlt(_localctx, 9);
        setState(502);
        match(GLSLParser::VEC4);
        break;
      }

      case GLSLParser::DVEC2: {
        enterOuterAlt(_localctx, 10);
        setState(503);
        match(GLSLParser::DVEC2);
        break;
      }

      case GLSLParser::DVEC3: {
        enterOuterAlt(_localctx, 11);
        setState(504);
        match(GLSLParser::DVEC3);
        break;
      }

      case GLSLParser::DVEC4: {
        enterOuterAlt(_localctx, 12);
        setState(505);
        match(GLSLParser::DVEC4);
        break;
      }

      case GLSLParser::BVEC2: {
        enterOuterAlt(_localctx, 13);
        setState(506);
        match(GLSLParser::BVEC2);
        break;
      }

      case GLSLParser::BVEC3: {
        enterOuterAlt(_localctx, 14);
        setState(507);
        match(GLSLParser::BVEC3);
        break;
      }

      case GLSLParser::BVEC4: {
        enterOuterAlt(_localctx, 15);
        setState(508);
        match(GLSLParser::BVEC4);
        break;
      }

      case GLSLParser::IVEC2: {
        enterOuterAlt(_localctx, 16);
        setState(509);
        match(GLSLParser::IVEC2);
        break;
      }

      case GLSLParser::IVEC3: {
        enterOuterAlt(_localctx, 17);
        setState(510);
        match(GLSLParser::IVEC3);
        break;
      }

      case GLSLParser::IVEC4: {
        enterOuterAlt(_localctx, 18);
        setState(511);
        match(GLSLParser::IVEC4);
        break;
      }

      case GLSLParser::UVEC2: {
        enterOuterAlt(_localctx, 19);
        setState(512);
        match(GLSLParser::UVEC2);
        break;
      }

      case GLSLParser::UVEC3: {
        enterOuterAlt(_localctx, 20);
        setState(513);
        match(GLSLParser::UVEC3);
        break;
      }

      case GLSLParser::UVEC4: {
        enterOuterAlt(_localctx, 21);
        setState(514);
        match(GLSLParser::UVEC4);
        break;
      }

      case GLSLParser::MAT2: {
        enterOuterAlt(_localctx, 22);
        setState(515);
        match(GLSLParser::MAT2);
        break;
      }

      case GLSLParser::MAT3: {
        enterOuterAlt(_localctx, 23);
        setState(516);
        match(GLSLParser::MAT3);
        break;
      }

      case GLSLParser::MAT4: {
        enterOuterAlt(_localctx, 24);
        setState(517);
        match(GLSLParser::MAT4);
        break;
      }

      case GLSLParser::MAT2X2: {
        enterOuterAlt(_localctx, 25);
        setState(518);
        match(GLSLParser::MAT2X2);
        break;
      }

      case GLSLParser::MAT2X3: {
        enterOuterAlt(_localctx, 26);
        setState(519);
        match(GLSLParser::MAT2X3);
        break;
      }

      case GLSLParser::MAT2X4: {
        enterOuterAlt(_localctx, 27);
        setState(520);
        match(GLSLParser::MAT2X4);
        break;
      }

      case GLSLParser::MAT3X2: {
        enterOuterAlt(_localctx, 28);
        setState(521);
        match(GLSLParser::MAT3X2);
        break;
      }

      case GLSLParser::MAT3X3: {
        enterOuterAlt(_localctx, 29);
        setState(522);
        match(GLSLParser::MAT3X3);
        break;
      }

      case GLSLParser::MAT3X4: {
        enterOuterAlt(_localctx, 30);
        setState(523);
        match(GLSLParser::MAT3X4);
        break;
      }

      case GLSLParser::MAT4X2: {
        enterOuterAlt(_localctx, 31);
        setState(524);
        match(GLSLParser::MAT4X2);
        break;
      }

      case GLSLParser::MAT4X3: {
        enterOuterAlt(_localctx, 32);
        setState(525);
        match(GLSLParser::MAT4X3);
        break;
      }

      case GLSLParser::MAT4X4: {
        enterOuterAlt(_localctx, 33);
        setState(526);
        match(GLSLParser::MAT4X4);
        break;
      }

      case GLSLParser::DMAT2: {
        enterOuterAlt(_localctx, 34);
        setState(527);
        match(GLSLParser::DMAT2);
        break;
      }

      case GLSLParser::DMAT3: {
        enterOuterAlt(_localctx, 35);
        setState(528);
        match(GLSLParser::DMAT3);
        break;
      }

      case GLSLParser::DMAT4: {
        enterOuterAlt(_localctx, 36);
        setState(529);
        match(GLSLParser::DMAT4);
        break;
      }

      case GLSLParser::DMAT2X2: {
        enterOuterAlt(_localctx, 37);
        setState(530);
        match(GLSLParser::DMAT2X2);
        break;
      }

      case GLSLParser::DMAT2X3: {
        enterOuterAlt(_localctx, 38);
        setState(531);
        match(GLSLParser::DMAT2X3);
        break;
      }

      case GLSLParser::DMAT2X4: {
        enterOuterAlt(_localctx, 39);
        setState(532);
        match(GLSLParser::DMAT2X4);
        break;
      }

      case GLSLParser::DMAT3X2: {
        enterOuterAlt(_localctx, 40);
        setState(533);
        match(GLSLParser::DMAT3X2);
        break;
      }

      case GLSLParser::DMAT3X3: {
        enterOuterAlt(_localctx, 41);
        setState(534);
        match(GLSLParser::DMAT3X3);
        break;
      }

      case GLSLParser::DMAT3X4: {
        enterOuterAlt(_localctx, 42);
        setState(535);
        match(GLSLParser::DMAT3X4);
        break;
      }

      case GLSLParser::DMAT4X2: {
        enterOuterAlt(_localctx, 43);
        setState(536);
        match(GLSLParser::DMAT4X2);
        break;
      }

      case GLSLParser::DMAT4X3: {
        enterOuterAlt(_localctx, 44);
        setState(537);
        match(GLSLParser::DMAT4X3);
        break;
      }

      case GLSLParser::DMAT4X4: {
        enterOuterAlt(_localctx, 45);
        setState(538);
        match(GLSLParser::DMAT4X4);
        break;
      }

      case GLSLParser::ATOMIC_UINT: {
        enterOuterAlt(_localctx, 46);
        setState(539);
        match(GLSLParser::ATOMIC_UINT);
        break;
      }

      case GLSLParser::SAMPLER2D: {
        enterOuterAlt(_localctx, 47);
        setState(540);
        match(GLSLParser::SAMPLER2D);
        break;
      }

      case GLSLParser::SAMPLER3D: {
        enterOuterAlt(_localctx, 48);
        setState(541);
        match(GLSLParser::SAMPLER3D);
        break;
      }

      case GLSLParser::SAMPLERCUBE: {
        enterOuterAlt(_localctx, 49);
        setState(542);
        match(GLSLParser::SAMPLERCUBE);
        break;
      }

      case GLSLParser::SAMPLER2DSHADOW: {
        enterOuterAlt(_localctx, 50);
        setState(543);
        match(GLSLParser::SAMPLER2DSHADOW);
        break;
      }

      case GLSLParser::SAMPLERCUBESHADOW: {
        enterOuterAlt(_localctx, 51);
        setState(544);
        match(GLSLParser::SAMPLERCUBESHADOW);
        break;
      }

      case GLSLParser::SAMPLER2DARRAY: {
        enterOuterAlt(_localctx, 52);
        setState(545);
        match(GLSLParser::SAMPLER2DARRAY);
        break;
      }

      case GLSLParser::SAMPLER2DARRAYSHADOW: {
        enterOuterAlt(_localctx, 53);
        setState(546);
        match(GLSLParser::SAMPLER2DARRAYSHADOW);
        break;
      }

      case GLSLParser::SAMPLERCUBEARRAY: {
        enterOuterAlt(_localctx, 54);
        setState(547);
        match(GLSLParser::SAMPLERCUBEARRAY);
        break;
      }

      case GLSLParser::SAMPLERCUBEARRAYSHADOW: {
        enterOuterAlt(_localctx, 55);
        setState(548);
        match(GLSLParser::SAMPLERCUBEARRAYSHADOW);
        break;
      }

      case GLSLParser::ISAMPLER2D: {
        enterOuterAlt(_localctx, 56);
        setState(549);
        match(GLSLParser::ISAMPLER2D);
        break;
      }

      case GLSLParser::ISAMPLER3D: {
        enterOuterAlt(_localctx, 57);
        setState(550);
        match(GLSLParser::ISAMPLER3D);
        break;
      }

      case GLSLParser::ISAMPLERCUBE: {
        enterOuterAlt(_localctx, 58);
        setState(551);
        match(GLSLParser::ISAMPLERCUBE);
        break;
      }

      case GLSLParser::ISAMPLER2DARRAY: {
        enterOuterAlt(_localctx, 59);
        setState(552);
        match(GLSLParser::ISAMPLER2DARRAY);
        break;
      }

      case GLSLParser::ISAMPLERCUBEARRAY: {
        enterOuterAlt(_localctx, 60);
        setState(553);
        match(GLSLParser::ISAMPLERCUBEARRAY);
        break;
      }

      case GLSLParser::USAMPLER2D: {
        enterOuterAlt(_localctx, 61);
        setState(554);
        match(GLSLParser::USAMPLER2D);
        break;
      }

      case GLSLParser::USAMPLER3D: {
        enterOuterAlt(_localctx, 62);
        setState(555);
        match(GLSLParser::USAMPLER3D);
        break;
      }

      case GLSLParser::USAMPLERCUBE: {
        enterOuterAlt(_localctx, 63);
        setState(556);
        match(GLSLParser::USAMPLERCUBE);
        break;
      }

      case GLSLParser::USAMPLER2DARRAY: {
        enterOuterAlt(_localctx, 64);
        setState(557);
        match(GLSLParser::USAMPLER2DARRAY);
        break;
      }

      case GLSLParser::USAMPLERCUBEARRAY: {
        enterOuterAlt(_localctx, 65);
        setState(558);
        match(GLSLParser::USAMPLERCUBEARRAY);
        break;
      }

      case GLSLParser::SAMPLER1D: {
        enterOuterAlt(_localctx, 66);
        setState(559);
        match(GLSLParser::SAMPLER1D);
        break;
      }

      case GLSLParser::SAMPLER1DSHADOW: {
        enterOuterAlt(_localctx, 67);
        setState(560);
        match(GLSLParser::SAMPLER1DSHADOW);
        break;
      }

      case GLSLParser::SAMPLER1DARRAY: {
        enterOuterAlt(_localctx, 68);
        setState(561);
        match(GLSLParser::SAMPLER1DARRAY);
        break;
      }

      case GLSLParser::SAMPLER1DARRAYSHADOW: {
        enterOuterAlt(_localctx, 69);
        setState(562);
        match(GLSLParser::SAMPLER1DARRAYSHADOW);
        break;
      }

      case GLSLParser::ISAMPLER1D: {
        enterOuterAlt(_localctx, 70);
        setState(563);
        match(GLSLParser::ISAMPLER1D);
        break;
      }

      case GLSLParser::ISAMPLER1DARRAY: {
        enterOuterAlt(_localctx, 71);
        setState(564);
        match(GLSLParser::ISAMPLER1DARRAY);
        break;
      }

      case GLSLParser::USAMPLER1D: {
        enterOuterAlt(_localctx, 72);
        setState(565);
        match(GLSLParser::USAMPLER1D);
        break;
      }

      case GLSLParser::USAMPLER1DARRAY: {
        enterOuterAlt(_localctx, 73);
        setState(566);
        match(GLSLParser::USAMPLER1DARRAY);
        break;
      }

      case GLSLParser::SAMPLER2DRECT: {
        enterOuterAlt(_localctx, 74);
        setState(567);
        match(GLSLParser::SAMPLER2DRECT);
        break;
      }

      case GLSLParser::SAMPLER2DRECTSHADOW: {
        enterOuterAlt(_localctx, 75);
        setState(568);
        match(GLSLParser::SAMPLER2DRECTSHADOW);
        break;
      }

      case GLSLParser::ISAMPLER2DRECT: {
        enterOuterAlt(_localctx, 76);
        setState(569);
        match(GLSLParser::ISAMPLER2DRECT);
        break;
      }

      case GLSLParser::USAMPLER2DRECT: {
        enterOuterAlt(_localctx, 77);
        setState(570);
        match(GLSLParser::USAMPLER2DRECT);
        break;
      }

      case GLSLParser::SAMPLERBUFFER: {
        enterOuterAlt(_localctx, 78);
        setState(571);
        match(GLSLParser::SAMPLERBUFFER);
        break;
      }

      case GLSLParser::ISAMPLERBUFFER: {
        enterOuterAlt(_localctx, 79);
        setState(572);
        match(GLSLParser::ISAMPLERBUFFER);
        break;
      }

      case GLSLParser::USAMPLERBUFFER: {
        enterOuterAlt(_localctx, 80);
        setState(573);
        match(GLSLParser::USAMPLERBUFFER);
        break;
      }

      case GLSLParser::SAMPLER2DMS: {
        enterOuterAlt(_localctx, 81);
        setState(574);
        match(GLSLParser::SAMPLER2DMS);
        break;
      }

      case GLSLParser::ISAMPLER2DMS: {
        enterOuterAlt(_localctx, 82);
        setState(575);
        match(GLSLParser::ISAMPLER2DMS);
        break;
      }

      case GLSLParser::USAMPLER2DMS: {
        enterOuterAlt(_localctx, 83);
        setState(576);
        match(GLSLParser::USAMPLER2DMS);
        break;
      }

      case GLSLParser::SAMPLER2DMSARRAY: {
        enterOuterAlt(_localctx, 84);
        setState(577);
        match(GLSLParser::SAMPLER2DMSARRAY);
        break;
      }

      case GLSLParser::ISAMPLER2DMSARRAY: {
        enterOuterAlt(_localctx, 85);
        setState(578);
        match(GLSLParser::ISAMPLER2DMSARRAY);
        break;
      }

      case GLSLParser::USAMPLER2DMSARRAY: {
        enterOuterAlt(_localctx, 86);
        setState(579);
        match(GLSLParser::USAMPLER2DMSARRAY);
        break;
      }

      case GLSLParser::IMAGE2D: {
        enterOuterAlt(_localctx, 87);
        setState(580);
        match(GLSLParser::IMAGE2D);
        break;
      }

      case GLSLParser::IIMAGE2D: {
        enterOuterAlt(_localctx, 88);
        setState(581);
        match(GLSLParser::IIMAGE2D);
        break;
      }

      case GLSLParser::UIMAGE2D: {
        enterOuterAlt(_localctx, 89);
        setState(582);
        match(GLSLParser::UIMAGE2D);
        break;
      }

      case GLSLParser::IMAGE3D: {
        enterOuterAlt(_localctx, 90);
        setState(583);
        match(GLSLParser::IMAGE3D);
        break;
      }

      case GLSLParser::IIMAGE3D: {
        enterOuterAlt(_localctx, 91);
        setState(584);
        match(GLSLParser::IIMAGE3D);
        break;
      }

      case GLSLParser::UIMAGE3D: {
        enterOuterAlt(_localctx, 92);
        setState(585);
        match(GLSLParser::UIMAGE3D);
        break;
      }

      case GLSLParser::IMAGECUBE: {
        enterOuterAlt(_localctx, 93);
        setState(586);
        match(GLSLParser::IMAGECUBE);
        break;
      }

      case GLSLParser::IIMAGECUBE: {
        enterOuterAlt(_localctx, 94);
        setState(587);
        match(GLSLParser::IIMAGECUBE);
        break;
      }

      case GLSLParser::UIMAGECUBE: {
        enterOuterAlt(_localctx, 95);
        setState(588);
        match(GLSLParser::UIMAGECUBE);
        break;
      }

      case GLSLParser::IMAGEBUFFER: {
        enterOuterAlt(_localctx, 96);
        setState(589);
        match(GLSLParser::IMAGEBUFFER);
        break;
      }

      case GLSLParser::IIMAGEBUFFER: {
        enterOuterAlt(_localctx, 97);
        setState(590);
        match(GLSLParser::IIMAGEBUFFER);
        break;
      }

      case GLSLParser::UIMAGEBUFFER: {
        enterOuterAlt(_localctx, 98);
        setState(591);
        match(GLSLParser::UIMAGEBUFFER);
        break;
      }

      case GLSLParser::IMAGE1D: {
        enterOuterAlt(_localctx, 99);
        setState(592);
        match(GLSLParser::IMAGE1D);
        break;
      }

      case GLSLParser::IIMAGE1D: {
        enterOuterAlt(_localctx, 100);
        setState(593);
        match(GLSLParser::IIMAGE1D);
        break;
      }

      case GLSLParser::UIMAGE1D: {
        enterOuterAlt(_localctx, 101);
        setState(594);
        match(GLSLParser::UIMAGE1D);
        break;
      }

      case GLSLParser::IMAGE1DARRAY: {
        enterOuterAlt(_localctx, 102);
        setState(595);
        match(GLSLParser::IMAGE1DARRAY);
        break;
      }

      case GLSLParser::IIMAGE1DARRAY: {
        enterOuterAlt(_localctx, 103);
        setState(596);
        match(GLSLParser::IIMAGE1DARRAY);
        break;
      }

      case GLSLParser::UIMAGE1DARRAY: {
        enterOuterAlt(_localctx, 104);
        setState(597);
        match(GLSLParser::UIMAGE1DARRAY);
        break;
      }

      case GLSLParser::IMAGE2DRECT: {
        enterOuterAlt(_localctx, 105);
        setState(598);
        match(GLSLParser::IMAGE2DRECT);
        break;
      }

      case GLSLParser::IIMAGE2DRECT: {
        enterOuterAlt(_localctx, 106);
        setState(599);
        match(GLSLParser::IIMAGE2DRECT);
        break;
      }

      case GLSLParser::UIMAGE2DRECT: {
        enterOuterAlt(_localctx, 107);
        setState(600);
        match(GLSLParser::UIMAGE2DRECT);
        break;
      }

      case GLSLParser::IMAGE2DARRAY: {
        enterOuterAlt(_localctx, 108);
        setState(601);
        match(GLSLParser::IMAGE2DARRAY);
        break;
      }

      case GLSLParser::IIMAGE2DARRAY: {
        enterOuterAlt(_localctx, 109);
        setState(602);
        match(GLSLParser::IIMAGE2DARRAY);
        break;
      }

      case GLSLParser::UIMAGE2DARRAY: {
        enterOuterAlt(_localctx, 110);
        setState(603);
        match(GLSLParser::UIMAGE2DARRAY);
        break;
      }

      case GLSLParser::IMAGECUBEARRAY: {
        enterOuterAlt(_localctx, 111);
        setState(604);
        match(GLSLParser::IMAGECUBEARRAY);
        break;
      }

      case GLSLParser::IIMAGECUBEARRAY: {
        enterOuterAlt(_localctx, 112);
        setState(605);
        match(GLSLParser::IIMAGECUBEARRAY);
        break;
      }

      case GLSLParser::UIMAGECUBEARRAY: {
        enterOuterAlt(_localctx, 113);
        setState(606);
        match(GLSLParser::UIMAGECUBEARRAY);
        break;
      }

      case GLSLParser::IMAGE2DMS: {
        enterOuterAlt(_localctx, 114);
        setState(607);
        match(GLSLParser::IMAGE2DMS);
        break;
      }

      case GLSLParser::IIMAGE2DMS: {
        enterOuterAlt(_localctx, 115);
        setState(608);
        match(GLSLParser::IIMAGE2DMS);
        break;
      }

      case GLSLParser::UIMAGE2DMS: {
        enterOuterAlt(_localctx, 116);
        setState(609);
        match(GLSLParser::UIMAGE2DMS);
        break;
      }

      case GLSLParser::IMAGE2DMSARRAY: {
        enterOuterAlt(_localctx, 117);
        setState(610);
        match(GLSLParser::IMAGE2DMSARRAY);
        break;
      }

      case GLSLParser::IIMAGE2DMSARRAY: {
        enterOuterAlt(_localctx, 118);
        setState(611);
        match(GLSLParser::IIMAGE2DMSARRAY);
        break;
      }

      case GLSLParser::UIMAGE2DMSARRAY: {
        enterOuterAlt(_localctx, 119);
        setState(612);
        match(GLSLParser::UIMAGE2DMSARRAY);
        break;
      }

      case GLSLParser::STRUCT: {
        enterOuterAlt(_localctx, 120);
        setState(613);
        struct_specifier();
        break;
      }

      case GLSLParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 121);
        setState(614);
        type_name();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Precision_qualifierContext ------------------------------------------------------------------

GLSLParser::Precision_qualifierContext::Precision_qualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Precision_qualifierContext::HIGHP() {
  return getToken(GLSLParser::HIGHP, 0);
}

tree::TerminalNode* GLSLParser::Precision_qualifierContext::MEDIUMP() {
  return getToken(GLSLParser::MEDIUMP, 0);
}

tree::TerminalNode* GLSLParser::Precision_qualifierContext::LOWP() {
  return getToken(GLSLParser::LOWP, 0);
}


size_t GLSLParser::Precision_qualifierContext::getRuleIndex() const {
  return GLSLParser::RulePrecision_qualifier;
}

void GLSLParser::Precision_qualifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrecision_qualifier(this);
}

void GLSLParser::Precision_qualifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrecision_qualifier(this);
}

GLSLParser::Precision_qualifierContext* GLSLParser::precision_qualifier() {
  Precision_qualifierContext *_localctx = _tracker.createInstance<Precision_qualifierContext>(_ctx, getState());
  enterRule(_localctx, 84, GLSLParser::RulePrecision_qualifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(617);
    _la = _input->LA(1);
    if (!(_la == GLSLParser::HIGHP || _la == GLSLParser::LOWP

    || _la == GLSLParser::MEDIUMP)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Struct_specifierContext ------------------------------------------------------------------

GLSLParser::Struct_specifierContext::Struct_specifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Struct_specifierContext::STRUCT() {
  return getToken(GLSLParser::STRUCT, 0);
}

tree::TerminalNode* GLSLParser::Struct_specifierContext::LEFT_BRACE() {
  return getToken(GLSLParser::LEFT_BRACE, 0);
}

GLSLParser::Struct_declaration_listContext* GLSLParser::Struct_specifierContext::struct_declaration_list() {
  return getRuleContext<GLSLParser::Struct_declaration_listContext>(0);
}

tree::TerminalNode* GLSLParser::Struct_specifierContext::RIGHT_BRACE() {
  return getToken(GLSLParser::RIGHT_BRACE, 0);
}

tree::TerminalNode* GLSLParser::Struct_specifierContext::IDENTIFIER() {
  return getToken(GLSLParser::IDENTIFIER, 0);
}


size_t GLSLParser::Struct_specifierContext::getRuleIndex() const {
  return GLSLParser::RuleStruct_specifier;
}

void GLSLParser::Struct_specifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStruct_specifier(this);
}

void GLSLParser::Struct_specifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStruct_specifier(this);
}

GLSLParser::Struct_specifierContext* GLSLParser::struct_specifier() {
  Struct_specifierContext *_localctx = _tracker.createInstance<Struct_specifierContext>(_ctx, getState());
  enterRule(_localctx, 86, GLSLParser::RuleStruct_specifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(619);
    match(GLSLParser::STRUCT);
    setState(621);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GLSLParser::IDENTIFIER) {
      setState(620);
      match(GLSLParser::IDENTIFIER);
    }
    setState(623);
    match(GLSLParser::LEFT_BRACE);
    setState(624);
    struct_declaration_list();
    setState(625);
    match(GLSLParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Struct_declaration_listContext ------------------------------------------------------------------

GLSLParser::Struct_declaration_listContext::Struct_declaration_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GLSLParser::Struct_declarationContext *> GLSLParser::Struct_declaration_listContext::struct_declaration() {
  return getRuleContexts<GLSLParser::Struct_declarationContext>();
}

GLSLParser::Struct_declarationContext* GLSLParser::Struct_declaration_listContext::struct_declaration(size_t i) {
  return getRuleContext<GLSLParser::Struct_declarationContext>(i);
}


size_t GLSLParser::Struct_declaration_listContext::getRuleIndex() const {
  return GLSLParser::RuleStruct_declaration_list;
}

void GLSLParser::Struct_declaration_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStruct_declaration_list(this);
}

void GLSLParser::Struct_declaration_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStruct_declaration_list(this);
}

GLSLParser::Struct_declaration_listContext* GLSLParser::struct_declaration_list() {
  Struct_declaration_listContext *_localctx = _tracker.createInstance<Struct_declaration_listContext>(_ctx, getState());
  enterRule(_localctx, 88, GLSLParser::RuleStruct_declaration_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(628); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(627);
      struct_declaration();
      setState(630); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -713233064466) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -11540474112237569) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 4503599358955263) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & 1535) != 0) || _la == GLSLParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Struct_declarationContext ------------------------------------------------------------------

GLSLParser::Struct_declarationContext::Struct_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Type_specifierContext* GLSLParser::Struct_declarationContext::type_specifier() {
  return getRuleContext<GLSLParser::Type_specifierContext>(0);
}

GLSLParser::Struct_declarator_listContext* GLSLParser::Struct_declarationContext::struct_declarator_list() {
  return getRuleContext<GLSLParser::Struct_declarator_listContext>(0);
}

tree::TerminalNode* GLSLParser::Struct_declarationContext::SEMICOLON() {
  return getToken(GLSLParser::SEMICOLON, 0);
}

GLSLParser::Type_qualifierContext* GLSLParser::Struct_declarationContext::type_qualifier() {
  return getRuleContext<GLSLParser::Type_qualifierContext>(0);
}


size_t GLSLParser::Struct_declarationContext::getRuleIndex() const {
  return GLSLParser::RuleStruct_declaration;
}

void GLSLParser::Struct_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStruct_declaration(this);
}

void GLSLParser::Struct_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStruct_declaration(this);
}

GLSLParser::Struct_declarationContext* GLSLParser::struct_declaration() {
  Struct_declarationContext *_localctx = _tracker.createInstance<Struct_declarationContext>(_ctx, getState());
  enterRule(_localctx, 90, GLSLParser::RuleStruct_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(641);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GLSLParser::ATOMIC_UINT:
      case GLSLParser::BOOL:
      case GLSLParser::BVEC2:
      case GLSLParser::BVEC3:
      case GLSLParser::BVEC4:
      case GLSLParser::DMAT2:
      case GLSLParser::DMAT2X2:
      case GLSLParser::DMAT2X3:
      case GLSLParser::DMAT2X4:
      case GLSLParser::DMAT3:
      case GLSLParser::DMAT3X2:
      case GLSLParser::DMAT3X3:
      case GLSLParser::DMAT3X4:
      case GLSLParser::DMAT4:
      case GLSLParser::DMAT4X2:
      case GLSLParser::DMAT4X3:
      case GLSLParser::DMAT4X4:
      case GLSLParser::DOUBLE:
      case GLSLParser::DVEC2:
      case GLSLParser::DVEC3:
      case GLSLParser::DVEC4:
      case GLSLParser::FLOAT:
      case GLSLParser::IIMAGE1D:
      case GLSLParser::IIMAGE1DARRAY:
      case GLSLParser::IIMAGE2D:
      case GLSLParser::IIMAGE2DARRAY:
      case GLSLParser::IIMAGE2DMS:
      case GLSLParser::IIMAGE2DMSARRAY:
      case GLSLParser::IIMAGE2DRECT:
      case GLSLParser::IIMAGE3D:
      case GLSLParser::IIMAGEBUFFER:
      case GLSLParser::IIMAGECUBE:
      case GLSLParser::IIMAGECUBEARRAY:
      case GLSLParser::IMAGE1D:
      case GLSLParser::IMAGE1DARRAY:
      case GLSLParser::IMAGE2D:
      case GLSLParser::IMAGE2DARRAY:
      case GLSLParser::IMAGE2DMS:
      case GLSLParser::IMAGE2DMSARRAY:
      case GLSLParser::IMAGE2DRECT:
      case GLSLParser::IMAGE3D:
      case GLSLParser::IMAGEBUFFER:
      case GLSLParser::IMAGECUBE:
      case GLSLParser::IMAGECUBEARRAY:
      case GLSLParser::INT:
      case GLSLParser::ISAMPLER1D:
      case GLSLParser::ISAMPLER1DARRAY:
      case GLSLParser::ISAMPLER2D:
      case GLSLParser::ISAMPLER2DARRAY:
      case GLSLParser::ISAMPLER2DMS:
      case GLSLParser::ISAMPLER2DMSARRAY:
      case GLSLParser::ISAMPLER2DRECT:
      case GLSLParser::ISAMPLER3D:
      case GLSLParser::ISAMPLERBUFFER:
      case GLSLParser::ISAMPLERCUBE:
      case GLSLParser::ISAMPLERCUBEARRAY:
      case GLSLParser::IVEC2:
      case GLSLParser::IVEC3:
      case GLSLParser::IVEC4:
      case GLSLParser::MAT2:
      case GLSLParser::MAT2X2:
      case GLSLParser::MAT2X3:
      case GLSLParser::MAT2X4:
      case GLSLParser::MAT3:
      case GLSLParser::MAT3X2:
      case GLSLParser::MAT3X3:
      case GLSLParser::MAT3X4:
      case GLSLParser::MAT4:
      case GLSLParser::MAT4X2:
      case GLSLParser::MAT4X3:
      case GLSLParser::MAT4X4:
      case GLSLParser::SAMPLER1D:
      case GLSLParser::SAMPLER1DARRAY:
      case GLSLParser::SAMPLER1DARRAYSHADOW:
      case GLSLParser::SAMPLER1DSHADOW:
      case GLSLParser::SAMPLER2D:
      case GLSLParser::SAMPLER2DARRAY:
      case GLSLParser::SAMPLER2DARRAYSHADOW:
      case GLSLParser::SAMPLER2DMS:
      case GLSLParser::SAMPLER2DMSARRAY:
      case GLSLParser::SAMPLER2DRECT:
      case GLSLParser::SAMPLER2DRECTSHADOW:
      case GLSLParser::SAMPLER2DSHADOW:
      case GLSLParser::SAMPLER3D:
      case GLSLParser::SAMPLERBUFFER:
      case GLSLParser::SAMPLERCUBE:
      case GLSLParser::SAMPLERCUBEARRAY:
      case GLSLParser::SAMPLERCUBEARRAYSHADOW:
      case GLSLParser::SAMPLERCUBESHADOW:
      case GLSLParser::STRUCT:
      case GLSLParser::UIMAGE1D:
      case GLSLParser::UIMAGE1DARRAY:
      case GLSLParser::UIMAGE2D:
      case GLSLParser::UIMAGE2DARRAY:
      case GLSLParser::UIMAGE2DMS:
      case GLSLParser::UIMAGE2DMSARRAY:
      case GLSLParser::UIMAGE2DRECT:
      case GLSLParser::UIMAGE3D:
      case GLSLParser::UIMAGEBUFFER:
      case GLSLParser::UIMAGECUBE:
      case GLSLParser::UIMAGECUBEARRAY:
      case GLSLParser::UINT:
      case GLSLParser::USAMPLER1D:
      case GLSLParser::USAMPLER1DARRAY:
      case GLSLParser::USAMPLER2D:
      case GLSLParser::USAMPLER2DARRAY:
      case GLSLParser::USAMPLER2DMS:
      case GLSLParser::USAMPLER2DMSARRAY:
      case GLSLParser::USAMPLER2DRECT:
      case GLSLParser::USAMPLER3D:
      case GLSLParser::USAMPLERBUFFER:
      case GLSLParser::USAMPLERCUBE:
      case GLSLParser::USAMPLERCUBEARRAY:
      case GLSLParser::UVEC2:
      case GLSLParser::UVEC3:
      case GLSLParser::UVEC4:
      case GLSLParser::VEC2:
      case GLSLParser::VEC3:
      case GLSLParser::VEC4:
      case GLSLParser::VOID:
      case GLSLParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(632);
        type_specifier();
        setState(633);
        struct_declarator_list();
        setState(634);
        match(GLSLParser::SEMICOLON);
        break;
      }

      case GLSLParser::ATTRIBUTE:
      case GLSLParser::BUFFER:
      case GLSLParser::CENTROID:
      case GLSLParser::COHERENT:
      case GLSLParser::CONST:
      case GLSLParser::FLAT:
      case GLSLParser::HIGHP:
      case GLSLParser::IN:
      case GLSLParser::INOUT:
      case GLSLParser::INVARIANT:
      case GLSLParser::LAYOUT:
      case GLSLParser::LOWP:
      case GLSLParser::MEDIUMP:
      case GLSLParser::NOPERSPECTIVE:
      case GLSLParser::OUT:
      case GLSLParser::PATCH:
      case GLSLParser::PRECISE:
      case GLSLParser::READONLY:
      case GLSLParser::RESTRICT:
      case GLSLParser::SAMPLE:
      case GLSLParser::SHARED:
      case GLSLParser::SMOOTH:
      case GLSLParser::SUBROUTINE:
      case GLSLParser::UNIFORM:
      case GLSLParser::VARYING:
      case GLSLParser::VOLATILE:
      case GLSLParser::WRITEONLY: {
        enterOuterAlt(_localctx, 2);
        setState(636);
        type_qualifier();
        setState(637);
        type_specifier();
        setState(638);
        struct_declarator_list();
        setState(639);
        match(GLSLParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Struct_declarator_listContext ------------------------------------------------------------------

GLSLParser::Struct_declarator_listContext::Struct_declarator_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GLSLParser::Struct_declaratorContext *> GLSLParser::Struct_declarator_listContext::struct_declarator() {
  return getRuleContexts<GLSLParser::Struct_declaratorContext>();
}

GLSLParser::Struct_declaratorContext* GLSLParser::Struct_declarator_listContext::struct_declarator(size_t i) {
  return getRuleContext<GLSLParser::Struct_declaratorContext>(i);
}

std::vector<tree::TerminalNode *> GLSLParser::Struct_declarator_listContext::COMMA() {
  return getTokens(GLSLParser::COMMA);
}

tree::TerminalNode* GLSLParser::Struct_declarator_listContext::COMMA(size_t i) {
  return getToken(GLSLParser::COMMA, i);
}


size_t GLSLParser::Struct_declarator_listContext::getRuleIndex() const {
  return GLSLParser::RuleStruct_declarator_list;
}

void GLSLParser::Struct_declarator_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStruct_declarator_list(this);
}

void GLSLParser::Struct_declarator_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStruct_declarator_list(this);
}

GLSLParser::Struct_declarator_listContext* GLSLParser::struct_declarator_list() {
  Struct_declarator_listContext *_localctx = _tracker.createInstance<Struct_declarator_listContext>(_ctx, getState());
  enterRule(_localctx, 92, GLSLParser::RuleStruct_declarator_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(643);
    struct_declarator();
    setState(648);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == GLSLParser::COMMA) {
      setState(644);
      match(GLSLParser::COMMA);
      setState(645);
      struct_declarator();
      setState(650);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Struct_declaratorContext ------------------------------------------------------------------

GLSLParser::Struct_declaratorContext::Struct_declaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Struct_declaratorContext::IDENTIFIER() {
  return getToken(GLSLParser::IDENTIFIER, 0);
}

GLSLParser::Array_specifierContext* GLSLParser::Struct_declaratorContext::array_specifier() {
  return getRuleContext<GLSLParser::Array_specifierContext>(0);
}


size_t GLSLParser::Struct_declaratorContext::getRuleIndex() const {
  return GLSLParser::RuleStruct_declarator;
}

void GLSLParser::Struct_declaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStruct_declarator(this);
}

void GLSLParser::Struct_declaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStruct_declarator(this);
}

GLSLParser::Struct_declaratorContext* GLSLParser::struct_declarator() {
  Struct_declaratorContext *_localctx = _tracker.createInstance<Struct_declaratorContext>(_ctx, getState());
  enterRule(_localctx, 94, GLSLParser::RuleStruct_declarator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(651);
    match(GLSLParser::IDENTIFIER);
    setState(653);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == GLSLParser::LEFT_BRACKET) {
      setState(652);
      array_specifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InitializerContext ------------------------------------------------------------------

GLSLParser::InitializerContext::InitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Assignment_expressionContext* GLSLParser::InitializerContext::assignment_expression() {
  return getRuleContext<GLSLParser::Assignment_expressionContext>(0);
}

tree::TerminalNode* GLSLParser::InitializerContext::LEFT_BRACE() {
  return getToken(GLSLParser::LEFT_BRACE, 0);
}

GLSLParser::Initializer_listContext* GLSLParser::InitializerContext::initializer_list() {
  return getRuleContext<GLSLParser::Initializer_listContext>(0);
}

tree::TerminalNode* GLSLParser::InitializerContext::RIGHT_BRACE() {
  return getToken(GLSLParser::RIGHT_BRACE, 0);
}

tree::TerminalNode* GLSLParser::InitializerContext::COMMA() {
  return getToken(GLSLParser::COMMA, 0);
}


size_t GLSLParser::InitializerContext::getRuleIndex() const {
  return GLSLParser::RuleInitializer;
}

void GLSLParser::InitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitializer(this);
}

void GLSLParser::InitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitializer(this);
}

GLSLParser::InitializerContext* GLSLParser::initializer() {
  InitializerContext *_localctx = _tracker.createInstance<InitializerContext>(_ctx, getState());
  enterRule(_localctx, 96, GLSLParser::RuleInitializer);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(663);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GLSLParser::ATOMIC_UINT:
      case GLSLParser::BOOL:
      case GLSLParser::BVEC2:
      case GLSLParser::BVEC3:
      case GLSLParser::BVEC4:
      case GLSLParser::DMAT2:
      case GLSLParser::DMAT2X2:
      case GLSLParser::DMAT2X3:
      case GLSLParser::DMAT2X4:
      case GLSLParser::DMAT3:
      case GLSLParser::DMAT3X2:
      case GLSLParser::DMAT3X3:
      case GLSLParser::DMAT3X4:
      case GLSLParser::DMAT4:
      case GLSLParser::DMAT4X2:
      case GLSLParser::DMAT4X3:
      case GLSLParser::DMAT4X4:
      case GLSLParser::DOUBLE:
      case GLSLParser::DVEC2:
      case GLSLParser::DVEC3:
      case GLSLParser::DVEC4:
      case GLSLParser::FALSE:
      case GLSLParser::FLOAT:
      case GLSLParser::IIMAGE1D:
      case GLSLParser::IIMAGE1DARRAY:
      case GLSLParser::IIMAGE2D:
      case GLSLParser::IIMAGE2DARRAY:
      case GLSLParser::IIMAGE2DMS:
      case GLSLParser::IIMAGE2DMSARRAY:
      case GLSLParser::IIMAGE2DRECT:
      case GLSLParser::IIMAGE3D:
      case GLSLParser::IIMAGEBUFFER:
      case GLSLParser::IIMAGECUBE:
      case GLSLParser::IIMAGECUBEARRAY:
      case GLSLParser::IMAGE1D:
      case GLSLParser::IMAGE1DARRAY:
      case GLSLParser::IMAGE2D:
      case GLSLParser::IMAGE2DARRAY:
      case GLSLParser::IMAGE2DMS:
      case GLSLParser::IMAGE2DMSARRAY:
      case GLSLParser::IMAGE2DRECT:
      case GLSLParser::IMAGE3D:
      case GLSLParser::IMAGEBUFFER:
      case GLSLParser::IMAGECUBE:
      case GLSLParser::IMAGECUBEARRAY:
      case GLSLParser::INT:
      case GLSLParser::ISAMPLER1D:
      case GLSLParser::ISAMPLER1DARRAY:
      case GLSLParser::ISAMPLER2D:
      case GLSLParser::ISAMPLER2DARRAY:
      case GLSLParser::ISAMPLER2DMS:
      case GLSLParser::ISAMPLER2DMSARRAY:
      case GLSLParser::ISAMPLER2DRECT:
      case GLSLParser::ISAMPLER3D:
      case GLSLParser::ISAMPLERBUFFER:
      case GLSLParser::ISAMPLERCUBE:
      case GLSLParser::ISAMPLERCUBEARRAY:
      case GLSLParser::IVEC2:
      case GLSLParser::IVEC3:
      case GLSLParser::IVEC4:
      case GLSLParser::MAT2:
      case GLSLParser::MAT2X2:
      case GLSLParser::MAT2X3:
      case GLSLParser::MAT2X4:
      case GLSLParser::MAT3:
      case GLSLParser::MAT3X2:
      case GLSLParser::MAT3X3:
      case GLSLParser::MAT3X4:
      case GLSLParser::MAT4:
      case GLSLParser::MAT4X2:
      case GLSLParser::MAT4X3:
      case GLSLParser::MAT4X4:
      case GLSLParser::SAMPLER1D:
      case GLSLParser::SAMPLER1DARRAY:
      case GLSLParser::SAMPLER1DARRAYSHADOW:
      case GLSLParser::SAMPLER1DSHADOW:
      case GLSLParser::SAMPLER2D:
      case GLSLParser::SAMPLER2DARRAY:
      case GLSLParser::SAMPLER2DARRAYSHADOW:
      case GLSLParser::SAMPLER2DMS:
      case GLSLParser::SAMPLER2DMSARRAY:
      case GLSLParser::SAMPLER2DRECT:
      case GLSLParser::SAMPLER2DRECTSHADOW:
      case GLSLParser::SAMPLER2DSHADOW:
      case GLSLParser::SAMPLER3D:
      case GLSLParser::SAMPLERBUFFER:
      case GLSLParser::SAMPLERCUBE:
      case GLSLParser::SAMPLERCUBEARRAY:
      case GLSLParser::SAMPLERCUBEARRAYSHADOW:
      case GLSLParser::SAMPLERCUBESHADOW:
      case GLSLParser::STRUCT:
      case GLSLParser::TRUE:
      case GLSLParser::UIMAGE1D:
      case GLSLParser::UIMAGE1DARRAY:
      case GLSLParser::UIMAGE2D:
      case GLSLParser::UIMAGE2DARRAY:
      case GLSLParser::UIMAGE2DMS:
      case GLSLParser::UIMAGE2DMSARRAY:
      case GLSLParser::UIMAGE2DRECT:
      case GLSLParser::UIMAGE3D:
      case GLSLParser::UIMAGEBUFFER:
      case GLSLParser::UIMAGECUBE:
      case GLSLParser::UIMAGECUBEARRAY:
      case GLSLParser::UINT:
      case GLSLParser::USAMPLER1D:
      case GLSLParser::USAMPLER1DARRAY:
      case GLSLParser::USAMPLER2D:
      case GLSLParser::USAMPLER2DARRAY:
      case GLSLParser::USAMPLER2DMS:
      case GLSLParser::USAMPLER2DMSARRAY:
      case GLSLParser::USAMPLER2DRECT:
      case GLSLParser::USAMPLER3D:
      case GLSLParser::USAMPLERBUFFER:
      case GLSLParser::USAMPLERCUBE:
      case GLSLParser::USAMPLERCUBEARRAY:
      case GLSLParser::UVEC2:
      case GLSLParser::UVEC3:
      case GLSLParser::UVEC4:
      case GLSLParser::VEC2:
      case GLSLParser::VEC3:
      case GLSLParser::VEC4:
      case GLSLParser::VOID:
      case GLSLParser::BANG:
      case GLSLParser::DASH:
      case GLSLParser::DEC_OP:
      case GLSLParser::INC_OP:
      case GLSLParser::LEFT_PAREN:
      case GLSLParser::PLUS:
      case GLSLParser::TILDE:
      case GLSLParser::DOUBLECONSTANT:
      case GLSLParser::FLOATCONSTANT:
      case GLSLParser::INTCONSTANT:
      case GLSLParser::UINTCONSTANT:
      case GLSLParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(655);
        assignment_expression();
        break;
      }

      case GLSLParser::LEFT_BRACE: {
        enterOuterAlt(_localctx, 2);
        setState(656);
        match(GLSLParser::LEFT_BRACE);
        setState(657);
        initializer_list();
        setState(659);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GLSLParser::COMMA) {
          setState(658);
          match(GLSLParser::COMMA);
        }
        setState(661);
        match(GLSLParser::RIGHT_BRACE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initializer_listContext ------------------------------------------------------------------

GLSLParser::Initializer_listContext::Initializer_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GLSLParser::InitializerContext *> GLSLParser::Initializer_listContext::initializer() {
  return getRuleContexts<GLSLParser::InitializerContext>();
}

GLSLParser::InitializerContext* GLSLParser::Initializer_listContext::initializer(size_t i) {
  return getRuleContext<GLSLParser::InitializerContext>(i);
}

std::vector<tree::TerminalNode *> GLSLParser::Initializer_listContext::COMMA() {
  return getTokens(GLSLParser::COMMA);
}

tree::TerminalNode* GLSLParser::Initializer_listContext::COMMA(size_t i) {
  return getToken(GLSLParser::COMMA, i);
}


size_t GLSLParser::Initializer_listContext::getRuleIndex() const {
  return GLSLParser::RuleInitializer_list;
}

void GLSLParser::Initializer_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitializer_list(this);
}

void GLSLParser::Initializer_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitializer_list(this);
}

GLSLParser::Initializer_listContext* GLSLParser::initializer_list() {
  Initializer_listContext *_localctx = _tracker.createInstance<Initializer_listContext>(_ctx, getState());
  enterRule(_localctx, 98, GLSLParser::RuleInitializer_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(665);
    initializer();
    setState(670);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(666);
        match(GLSLParser::COMMA);
        setState(667);
        initializer(); 
      }
      setState(672);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Declaration_statementContext ------------------------------------------------------------------

GLSLParser::Declaration_statementContext::Declaration_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::DeclarationContext* GLSLParser::Declaration_statementContext::declaration() {
  return getRuleContext<GLSLParser::DeclarationContext>(0);
}


size_t GLSLParser::Declaration_statementContext::getRuleIndex() const {
  return GLSLParser::RuleDeclaration_statement;
}

void GLSLParser::Declaration_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclaration_statement(this);
}

void GLSLParser::Declaration_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclaration_statement(this);
}

GLSLParser::Declaration_statementContext* GLSLParser::declaration_statement() {
  Declaration_statementContext *_localctx = _tracker.createInstance<Declaration_statementContext>(_ctx, getState());
  enterRule(_localctx, 100, GLSLParser::RuleDeclaration_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(673);
    declaration();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

GLSLParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Compound_statementContext* GLSLParser::StatementContext::compound_statement() {
  return getRuleContext<GLSLParser::Compound_statementContext>(0);
}

GLSLParser::Simple_statementContext* GLSLParser::StatementContext::simple_statement() {
  return getRuleContext<GLSLParser::Simple_statementContext>(0);
}


size_t GLSLParser::StatementContext::getRuleIndex() const {
  return GLSLParser::RuleStatement;
}

void GLSLParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void GLSLParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

GLSLParser::StatementContext* GLSLParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 102, GLSLParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(677);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GLSLParser::LEFT_BRACE: {
        enterOuterAlt(_localctx, 1);
        setState(675);
        compound_statement();
        break;
      }

      case GLSLParser::ATOMIC_UINT:
      case GLSLParser::ATTRIBUTE:
      case GLSLParser::BOOL:
      case GLSLParser::BREAK:
      case GLSLParser::BUFFER:
      case GLSLParser::BVEC2:
      case GLSLParser::BVEC3:
      case GLSLParser::BVEC4:
      case GLSLParser::CASE:
      case GLSLParser::CENTROID:
      case GLSLParser::COHERENT:
      case GLSLParser::CONST:
      case GLSLParser::CONTINUE:
      case GLSLParser::DEFAULT:
      case GLSLParser::DISCARD:
      case GLSLParser::DMAT2:
      case GLSLParser::DMAT2X2:
      case GLSLParser::DMAT2X3:
      case GLSLParser::DMAT2X4:
      case GLSLParser::DMAT3:
      case GLSLParser::DMAT3X2:
      case GLSLParser::DMAT3X3:
      case GLSLParser::DMAT3X4:
      case GLSLParser::DMAT4:
      case GLSLParser::DMAT4X2:
      case GLSLParser::DMAT4X3:
      case GLSLParser::DMAT4X4:
      case GLSLParser::DO:
      case GLSLParser::DOUBLE:
      case GLSLParser::DVEC2:
      case GLSLParser::DVEC3:
      case GLSLParser::DVEC4:
      case GLSLParser::FALSE:
      case GLSLParser::FLAT:
      case GLSLParser::FLOAT:
      case GLSLParser::FOR:
      case GLSLParser::HIGHP:
      case GLSLParser::IF:
      case GLSLParser::IIMAGE1D:
      case GLSLParser::IIMAGE1DARRAY:
      case GLSLParser::IIMAGE2D:
      case GLSLParser::IIMAGE2DARRAY:
      case GLSLParser::IIMAGE2DMS:
      case GLSLParser::IIMAGE2DMSARRAY:
      case GLSLParser::IIMAGE2DRECT:
      case GLSLParser::IIMAGE3D:
      case GLSLParser::IIMAGEBUFFER:
      case GLSLParser::IIMAGECUBE:
      case GLSLParser::IIMAGECUBEARRAY:
      case GLSLParser::IMAGE1D:
      case GLSLParser::IMAGE1DARRAY:
      case GLSLParser::IMAGE2D:
      case GLSLParser::IMAGE2DARRAY:
      case GLSLParser::IMAGE2DMS:
      case GLSLParser::IMAGE2DMSARRAY:
      case GLSLParser::IMAGE2DRECT:
      case GLSLParser::IMAGE3D:
      case GLSLParser::IMAGEBUFFER:
      case GLSLParser::IMAGECUBE:
      case GLSLParser::IMAGECUBEARRAY:
      case GLSLParser::IN:
      case GLSLParser::INOUT:
      case GLSLParser::INT:
      case GLSLParser::INVARIANT:
      case GLSLParser::ISAMPLER1D:
      case GLSLParser::ISAMPLER1DARRAY:
      case GLSLParser::ISAMPLER2D:
      case GLSLParser::ISAMPLER2DARRAY:
      case GLSLParser::ISAMPLER2DMS:
      case GLSLParser::ISAMPLER2DMSARRAY:
      case GLSLParser::ISAMPLER2DRECT:
      case GLSLParser::ISAMPLER3D:
      case GLSLParser::ISAMPLERBUFFER:
      case GLSLParser::ISAMPLERCUBE:
      case GLSLParser::ISAMPLERCUBEARRAY:
      case GLSLParser::IVEC2:
      case GLSLParser::IVEC3:
      case GLSLParser::IVEC4:
      case GLSLParser::LAYOUT:
      case GLSLParser::LOWP:
      case GLSLParser::MAT2:
      case GLSLParser::MAT2X2:
      case GLSLParser::MAT2X3:
      case GLSLParser::MAT2X4:
      case GLSLParser::MAT3:
      case GLSLParser::MAT3X2:
      case GLSLParser::MAT3X3:
      case GLSLParser::MAT3X4:
      case GLSLParser::MAT4:
      case GLSLParser::MAT4X2:
      case GLSLParser::MAT4X3:
      case GLSLParser::MAT4X4:
      case GLSLParser::MEDIUMP:
      case GLSLParser::NOPERSPECTIVE:
      case GLSLParser::OUT:
      case GLSLParser::PATCH:
      case GLSLParser::PRECISE:
      case GLSLParser::PRECISION:
      case GLSLParser::READONLY:
      case GLSLParser::RESTRICT:
      case GLSLParser::RETURN:
      case GLSLParser::SAMPLE:
      case GLSLParser::SAMPLER1D:
      case GLSLParser::SAMPLER1DARRAY:
      case GLSLParser::SAMPLER1DARRAYSHADOW:
      case GLSLParser::SAMPLER1DSHADOW:
      case GLSLParser::SAMPLER2D:
      case GLSLParser::SAMPLER2DARRAY:
      case GLSLParser::SAMPLER2DARRAYSHADOW:
      case GLSLParser::SAMPLER2DMS:
      case GLSLParser::SAMPLER2DMSARRAY:
      case GLSLParser::SAMPLER2DRECT:
      case GLSLParser::SAMPLER2DRECTSHADOW:
      case GLSLParser::SAMPLER2DSHADOW:
      case GLSLParser::SAMPLER3D:
      case GLSLParser::SAMPLERBUFFER:
      case GLSLParser::SAMPLERCUBE:
      case GLSLParser::SAMPLERCUBEARRAY:
      case GLSLParser::SAMPLERCUBEARRAYSHADOW:
      case GLSLParser::SAMPLERCUBESHADOW:
      case GLSLParser::SHARED:
      case GLSLParser::SMOOTH:
      case GLSLParser::STRUCT:
      case GLSLParser::SUBROUTINE:
      case GLSLParser::SWITCH:
      case GLSLParser::TRUE:
      case GLSLParser::UIMAGE1D:
      case GLSLParser::UIMAGE1DARRAY:
      case GLSLParser::UIMAGE2D:
      case GLSLParser::UIMAGE2DARRAY:
      case GLSLParser::UIMAGE2DMS:
      case GLSLParser::UIMAGE2DMSARRAY:
      case GLSLParser::UIMAGE2DRECT:
      case GLSLParser::UIMAGE3D:
      case GLSLParser::UIMAGEBUFFER:
      case GLSLParser::UIMAGECUBE:
      case GLSLParser::UIMAGECUBEARRAY:
      case GLSLParser::UINT:
      case GLSLParser::UNIFORM:
      case GLSLParser::USAMPLER1D:
      case GLSLParser::USAMPLER1DARRAY:
      case GLSLParser::USAMPLER2D:
      case GLSLParser::USAMPLER2DARRAY:
      case GLSLParser::USAMPLER2DMS:
      case GLSLParser::USAMPLER2DMSARRAY:
      case GLSLParser::USAMPLER2DRECT:
      case GLSLParser::USAMPLER3D:
      case GLSLParser::USAMPLERBUFFER:
      case GLSLParser::USAMPLERCUBE:
      case GLSLParser::USAMPLERCUBEARRAY:
      case GLSLParser::UVEC2:
      case GLSLParser::UVEC3:
      case GLSLParser::UVEC4:
      case GLSLParser::VARYING:
      case GLSLParser::VEC2:
      case GLSLParser::VEC3:
      case GLSLParser::VEC4:
      case GLSLParser::VOID:
      case GLSLParser::VOLATILE:
      case GLSLParser::WHILE:
      case GLSLParser::WRITEONLY:
      case GLSLParser::BANG:
      case GLSLParser::DASH:
      case GLSLParser::DEC_OP:
      case GLSLParser::INC_OP:
      case GLSLParser::LEFT_PAREN:
      case GLSLParser::PLUS:
      case GLSLParser::SEMICOLON:
      case GLSLParser::TILDE:
      case GLSLParser::DOUBLECONSTANT:
      case GLSLParser::FLOATCONSTANT:
      case GLSLParser::INTCONSTANT:
      case GLSLParser::UINTCONSTANT:
      case GLSLParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 2);
        setState(676);
        simple_statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_statementContext ------------------------------------------------------------------

GLSLParser::Simple_statementContext::Simple_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Declaration_statementContext* GLSLParser::Simple_statementContext::declaration_statement() {
  return getRuleContext<GLSLParser::Declaration_statementContext>(0);
}

GLSLParser::Expression_statementContext* GLSLParser::Simple_statementContext::expression_statement() {
  return getRuleContext<GLSLParser::Expression_statementContext>(0);
}

GLSLParser::Selection_statementContext* GLSLParser::Simple_statementContext::selection_statement() {
  return getRuleContext<GLSLParser::Selection_statementContext>(0);
}

GLSLParser::Switch_statementContext* GLSLParser::Simple_statementContext::switch_statement() {
  return getRuleContext<GLSLParser::Switch_statementContext>(0);
}

GLSLParser::Case_labelContext* GLSLParser::Simple_statementContext::case_label() {
  return getRuleContext<GLSLParser::Case_labelContext>(0);
}

GLSLParser::Iteration_statementContext* GLSLParser::Simple_statementContext::iteration_statement() {
  return getRuleContext<GLSLParser::Iteration_statementContext>(0);
}

GLSLParser::Jump_statementContext* GLSLParser::Simple_statementContext::jump_statement() {
  return getRuleContext<GLSLParser::Jump_statementContext>(0);
}


size_t GLSLParser::Simple_statementContext::getRuleIndex() const {
  return GLSLParser::RuleSimple_statement;
}

void GLSLParser::Simple_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_statement(this);
}

void GLSLParser::Simple_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_statement(this);
}

GLSLParser::Simple_statementContext* GLSLParser::simple_statement() {
  Simple_statementContext *_localctx = _tracker.createInstance<Simple_statementContext>(_ctx, getState());
  enterRule(_localctx, 104, GLSLParser::RuleSimple_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(686);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(679);
      declaration_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(680);
      expression_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(681);
      selection_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(682);
      switch_statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(683);
      case_label();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(684);
      iteration_statement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(685);
      jump_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compound_statementContext ------------------------------------------------------------------

GLSLParser::Compound_statementContext::Compound_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Compound_statementContext::LEFT_BRACE() {
  return getToken(GLSLParser::LEFT_BRACE, 0);
}

tree::TerminalNode* GLSLParser::Compound_statementContext::RIGHT_BRACE() {
  return getToken(GLSLParser::RIGHT_BRACE, 0);
}

GLSLParser::Statement_listContext* GLSLParser::Compound_statementContext::statement_list() {
  return getRuleContext<GLSLParser::Statement_listContext>(0);
}


size_t GLSLParser::Compound_statementContext::getRuleIndex() const {
  return GLSLParser::RuleCompound_statement;
}

void GLSLParser::Compound_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompound_statement(this);
}

void GLSLParser::Compound_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompound_statement(this);
}

GLSLParser::Compound_statementContext* GLSLParser::compound_statement() {
  Compound_statementContext *_localctx = _tracker.createInstance<Compound_statementContext>(_ctx, getState());
  enterRule(_localctx, 106, GLSLParser::RuleCompound_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(688);
    match(GLSLParser::LEFT_BRACE);
    setState(690);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -8589934594) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -9007199321841665) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 4503599493205759) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & 2171300179101648895) != 0) || _la == GLSLParser::IDENTIFIER) {
      setState(689);
      statement_list();
    }
    setState(692);
    match(GLSLParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Statement_no_new_scopeContext ------------------------------------------------------------------

GLSLParser::Statement_no_new_scopeContext::Statement_no_new_scopeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Compound_statement_no_new_scopeContext* GLSLParser::Statement_no_new_scopeContext::compound_statement_no_new_scope() {
  return getRuleContext<GLSLParser::Compound_statement_no_new_scopeContext>(0);
}

GLSLParser::Simple_statementContext* GLSLParser::Statement_no_new_scopeContext::simple_statement() {
  return getRuleContext<GLSLParser::Simple_statementContext>(0);
}


size_t GLSLParser::Statement_no_new_scopeContext::getRuleIndex() const {
  return GLSLParser::RuleStatement_no_new_scope;
}

void GLSLParser::Statement_no_new_scopeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement_no_new_scope(this);
}

void GLSLParser::Statement_no_new_scopeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement_no_new_scope(this);
}

GLSLParser::Statement_no_new_scopeContext* GLSLParser::statement_no_new_scope() {
  Statement_no_new_scopeContext *_localctx = _tracker.createInstance<Statement_no_new_scopeContext>(_ctx, getState());
  enterRule(_localctx, 108, GLSLParser::RuleStatement_no_new_scope);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(696);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GLSLParser::LEFT_BRACE: {
        enterOuterAlt(_localctx, 1);
        setState(694);
        compound_statement_no_new_scope();
        break;
      }

      case GLSLParser::ATOMIC_UINT:
      case GLSLParser::ATTRIBUTE:
      case GLSLParser::BOOL:
      case GLSLParser::BREAK:
      case GLSLParser::BUFFER:
      case GLSLParser::BVEC2:
      case GLSLParser::BVEC3:
      case GLSLParser::BVEC4:
      case GLSLParser::CASE:
      case GLSLParser::CENTROID:
      case GLSLParser::COHERENT:
      case GLSLParser::CONST:
      case GLSLParser::CONTINUE:
      case GLSLParser::DEFAULT:
      case GLSLParser::DISCARD:
      case GLSLParser::DMAT2:
      case GLSLParser::DMAT2X2:
      case GLSLParser::DMAT2X3:
      case GLSLParser::DMAT2X4:
      case GLSLParser::DMAT3:
      case GLSLParser::DMAT3X2:
      case GLSLParser::DMAT3X3:
      case GLSLParser::DMAT3X4:
      case GLSLParser::DMAT4:
      case GLSLParser::DMAT4X2:
      case GLSLParser::DMAT4X3:
      case GLSLParser::DMAT4X4:
      case GLSLParser::DO:
      case GLSLParser::DOUBLE:
      case GLSLParser::DVEC2:
      case GLSLParser::DVEC3:
      case GLSLParser::DVEC4:
      case GLSLParser::FALSE:
      case GLSLParser::FLAT:
      case GLSLParser::FLOAT:
      case GLSLParser::FOR:
      case GLSLParser::HIGHP:
      case GLSLParser::IF:
      case GLSLParser::IIMAGE1D:
      case GLSLParser::IIMAGE1DARRAY:
      case GLSLParser::IIMAGE2D:
      case GLSLParser::IIMAGE2DARRAY:
      case GLSLParser::IIMAGE2DMS:
      case GLSLParser::IIMAGE2DMSARRAY:
      case GLSLParser::IIMAGE2DRECT:
      case GLSLParser::IIMAGE3D:
      case GLSLParser::IIMAGEBUFFER:
      case GLSLParser::IIMAGECUBE:
      case GLSLParser::IIMAGECUBEARRAY:
      case GLSLParser::IMAGE1D:
      case GLSLParser::IMAGE1DARRAY:
      case GLSLParser::IMAGE2D:
      case GLSLParser::IMAGE2DARRAY:
      case GLSLParser::IMAGE2DMS:
      case GLSLParser::IMAGE2DMSARRAY:
      case GLSLParser::IMAGE2DRECT:
      case GLSLParser::IMAGE3D:
      case GLSLParser::IMAGEBUFFER:
      case GLSLParser::IMAGECUBE:
      case GLSLParser::IMAGECUBEARRAY:
      case GLSLParser::IN:
      case GLSLParser::INOUT:
      case GLSLParser::INT:
      case GLSLParser::INVARIANT:
      case GLSLParser::ISAMPLER1D:
      case GLSLParser::ISAMPLER1DARRAY:
      case GLSLParser::ISAMPLER2D:
      case GLSLParser::ISAMPLER2DARRAY:
      case GLSLParser::ISAMPLER2DMS:
      case GLSLParser::ISAMPLER2DMSARRAY:
      case GLSLParser::ISAMPLER2DRECT:
      case GLSLParser::ISAMPLER3D:
      case GLSLParser::ISAMPLERBUFFER:
      case GLSLParser::ISAMPLERCUBE:
      case GLSLParser::ISAMPLERCUBEARRAY:
      case GLSLParser::IVEC2:
      case GLSLParser::IVEC3:
      case GLSLParser::IVEC4:
      case GLSLParser::LAYOUT:
      case GLSLParser::LOWP:
      case GLSLParser::MAT2:
      case GLSLParser::MAT2X2:
      case GLSLParser::MAT2X3:
      case GLSLParser::MAT2X4:
      case GLSLParser::MAT3:
      case GLSLParser::MAT3X2:
      case GLSLParser::MAT3X3:
      case GLSLParser::MAT3X4:
      case GLSLParser::MAT4:
      case GLSLParser::MAT4X2:
      case GLSLParser::MAT4X3:
      case GLSLParser::MAT4X4:
      case GLSLParser::MEDIUMP:
      case GLSLParser::NOPERSPECTIVE:
      case GLSLParser::OUT:
      case GLSLParser::PATCH:
      case GLSLParser::PRECISE:
      case GLSLParser::PRECISION:
      case GLSLParser::READONLY:
      case GLSLParser::RESTRICT:
      case GLSLParser::RETURN:
      case GLSLParser::SAMPLE:
      case GLSLParser::SAMPLER1D:
      case GLSLParser::SAMPLER1DARRAY:
      case GLSLParser::SAMPLER1DARRAYSHADOW:
      case GLSLParser::SAMPLER1DSHADOW:
      case GLSLParser::SAMPLER2D:
      case GLSLParser::SAMPLER2DARRAY:
      case GLSLParser::SAMPLER2DARRAYSHADOW:
      case GLSLParser::SAMPLER2DMS:
      case GLSLParser::SAMPLER2DMSARRAY:
      case GLSLParser::SAMPLER2DRECT:
      case GLSLParser::SAMPLER2DRECTSHADOW:
      case GLSLParser::SAMPLER2DSHADOW:
      case GLSLParser::SAMPLER3D:
      case GLSLParser::SAMPLERBUFFER:
      case GLSLParser::SAMPLERCUBE:
      case GLSLParser::SAMPLERCUBEARRAY:
      case GLSLParser::SAMPLERCUBEARRAYSHADOW:
      case GLSLParser::SAMPLERCUBESHADOW:
      case GLSLParser::SHARED:
      case GLSLParser::SMOOTH:
      case GLSLParser::STRUCT:
      case GLSLParser::SUBROUTINE:
      case GLSLParser::SWITCH:
      case GLSLParser::TRUE:
      case GLSLParser::UIMAGE1D:
      case GLSLParser::UIMAGE1DARRAY:
      case GLSLParser::UIMAGE2D:
      case GLSLParser::UIMAGE2DARRAY:
      case GLSLParser::UIMAGE2DMS:
      case GLSLParser::UIMAGE2DMSARRAY:
      case GLSLParser::UIMAGE2DRECT:
      case GLSLParser::UIMAGE3D:
      case GLSLParser::UIMAGEBUFFER:
      case GLSLParser::UIMAGECUBE:
      case GLSLParser::UIMAGECUBEARRAY:
      case GLSLParser::UINT:
      case GLSLParser::UNIFORM:
      case GLSLParser::USAMPLER1D:
      case GLSLParser::USAMPLER1DARRAY:
      case GLSLParser::USAMPLER2D:
      case GLSLParser::USAMPLER2DARRAY:
      case GLSLParser::USAMPLER2DMS:
      case GLSLParser::USAMPLER2DMSARRAY:
      case GLSLParser::USAMPLER2DRECT:
      case GLSLParser::USAMPLER3D:
      case GLSLParser::USAMPLERBUFFER:
      case GLSLParser::USAMPLERCUBE:
      case GLSLParser::USAMPLERCUBEARRAY:
      case GLSLParser::UVEC2:
      case GLSLParser::UVEC3:
      case GLSLParser::UVEC4:
      case GLSLParser::VARYING:
      case GLSLParser::VEC2:
      case GLSLParser::VEC3:
      case GLSLParser::VEC4:
      case GLSLParser::VOID:
      case GLSLParser::VOLATILE:
      case GLSLParser::WHILE:
      case GLSLParser::WRITEONLY:
      case GLSLParser::BANG:
      case GLSLParser::DASH:
      case GLSLParser::DEC_OP:
      case GLSLParser::INC_OP:
      case GLSLParser::LEFT_PAREN:
      case GLSLParser::PLUS:
      case GLSLParser::SEMICOLON:
      case GLSLParser::TILDE:
      case GLSLParser::DOUBLECONSTANT:
      case GLSLParser::FLOATCONSTANT:
      case GLSLParser::INTCONSTANT:
      case GLSLParser::UINTCONSTANT:
      case GLSLParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 2);
        setState(695);
        simple_statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compound_statement_no_new_scopeContext ------------------------------------------------------------------

GLSLParser::Compound_statement_no_new_scopeContext::Compound_statement_no_new_scopeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Compound_statement_no_new_scopeContext::LEFT_BRACE() {
  return getToken(GLSLParser::LEFT_BRACE, 0);
}

tree::TerminalNode* GLSLParser::Compound_statement_no_new_scopeContext::RIGHT_BRACE() {
  return getToken(GLSLParser::RIGHT_BRACE, 0);
}

GLSLParser::Statement_listContext* GLSLParser::Compound_statement_no_new_scopeContext::statement_list() {
  return getRuleContext<GLSLParser::Statement_listContext>(0);
}


size_t GLSLParser::Compound_statement_no_new_scopeContext::getRuleIndex() const {
  return GLSLParser::RuleCompound_statement_no_new_scope;
}

void GLSLParser::Compound_statement_no_new_scopeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompound_statement_no_new_scope(this);
}

void GLSLParser::Compound_statement_no_new_scopeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompound_statement_no_new_scope(this);
}

GLSLParser::Compound_statement_no_new_scopeContext* GLSLParser::compound_statement_no_new_scope() {
  Compound_statement_no_new_scopeContext *_localctx = _tracker.createInstance<Compound_statement_no_new_scopeContext>(_ctx, getState());
  enterRule(_localctx, 110, GLSLParser::RuleCompound_statement_no_new_scope);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(698);
    match(GLSLParser::LEFT_BRACE);
    setState(700);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -8589934594) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -9007199321841665) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 4503599493205759) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & 2171300179101648895) != 0) || _la == GLSLParser::IDENTIFIER) {
      setState(699);
      statement_list();
    }
    setState(702);
    match(GLSLParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Statement_listContext ------------------------------------------------------------------

GLSLParser::Statement_listContext::Statement_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GLSLParser::StatementContext *> GLSLParser::Statement_listContext::statement() {
  return getRuleContexts<GLSLParser::StatementContext>();
}

GLSLParser::StatementContext* GLSLParser::Statement_listContext::statement(size_t i) {
  return getRuleContext<GLSLParser::StatementContext>(i);
}


size_t GLSLParser::Statement_listContext::getRuleIndex() const {
  return GLSLParser::RuleStatement_list;
}

void GLSLParser::Statement_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement_list(this);
}

void GLSLParser::Statement_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement_list(this);
}

GLSLParser::Statement_listContext* GLSLParser::statement_list() {
  Statement_listContext *_localctx = _tracker.createInstance<Statement_listContext>(_ctx, getState());
  enterRule(_localctx, 112, GLSLParser::RuleStatement_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(705); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(704);
      statement();
      setState(707); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -8589934594) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -9007199321841665) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 4503599493205759) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & 2171300179101648895) != 0) || _la == GLSLParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expression_statementContext ------------------------------------------------------------------

GLSLParser::Expression_statementContext::Expression_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Expression_statementContext::SEMICOLON() {
  return getToken(GLSLParser::SEMICOLON, 0);
}

GLSLParser::ExpressionContext* GLSLParser::Expression_statementContext::expression() {
  return getRuleContext<GLSLParser::ExpressionContext>(0);
}


size_t GLSLParser::Expression_statementContext::getRuleIndex() const {
  return GLSLParser::RuleExpression_statement;
}

void GLSLParser::Expression_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression_statement(this);
}

void GLSLParser::Expression_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression_statement(this);
}

GLSLParser::Expression_statementContext* GLSLParser::expression_statement() {
  Expression_statementContext *_localctx = _tracker.createInstance<Expression_statementContext>(_ctx, getState());
  enterRule(_localctx, 114, GLSLParser::RuleExpression_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(713);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GLSLParser::SEMICOLON: {
        enterOuterAlt(_localctx, 1);
        setState(709);
        match(GLSLParser::SEMICOLON);
        break;
      }

      case GLSLParser::ATOMIC_UINT:
      case GLSLParser::BOOL:
      case GLSLParser::BVEC2:
      case GLSLParser::BVEC3:
      case GLSLParser::BVEC4:
      case GLSLParser::DMAT2:
      case GLSLParser::DMAT2X2:
      case GLSLParser::DMAT2X3:
      case GLSLParser::DMAT2X4:
      case GLSLParser::DMAT3:
      case GLSLParser::DMAT3X2:
      case GLSLParser::DMAT3X3:
      case GLSLParser::DMAT3X4:
      case GLSLParser::DMAT4:
      case GLSLParser::DMAT4X2:
      case GLSLParser::DMAT4X3:
      case GLSLParser::DMAT4X4:
      case GLSLParser::DOUBLE:
      case GLSLParser::DVEC2:
      case GLSLParser::DVEC3:
      case GLSLParser::DVEC4:
      case GLSLParser::FALSE:
      case GLSLParser::FLOAT:
      case GLSLParser::IIMAGE1D:
      case GLSLParser::IIMAGE1DARRAY:
      case GLSLParser::IIMAGE2D:
      case GLSLParser::IIMAGE2DARRAY:
      case GLSLParser::IIMAGE2DMS:
      case GLSLParser::IIMAGE2DMSARRAY:
      case GLSLParser::IIMAGE2DRECT:
      case GLSLParser::IIMAGE3D:
      case GLSLParser::IIMAGEBUFFER:
      case GLSLParser::IIMAGECUBE:
      case GLSLParser::IIMAGECUBEARRAY:
      case GLSLParser::IMAGE1D:
      case GLSLParser::IMAGE1DARRAY:
      case GLSLParser::IMAGE2D:
      case GLSLParser::IMAGE2DARRAY:
      case GLSLParser::IMAGE2DMS:
      case GLSLParser::IMAGE2DMSARRAY:
      case GLSLParser::IMAGE2DRECT:
      case GLSLParser::IMAGE3D:
      case GLSLParser::IMAGEBUFFER:
      case GLSLParser::IMAGECUBE:
      case GLSLParser::IMAGECUBEARRAY:
      case GLSLParser::INT:
      case GLSLParser::ISAMPLER1D:
      case GLSLParser::ISAMPLER1DARRAY:
      case GLSLParser::ISAMPLER2D:
      case GLSLParser::ISAMPLER2DARRAY:
      case GLSLParser::ISAMPLER2DMS:
      case GLSLParser::ISAMPLER2DMSARRAY:
      case GLSLParser::ISAMPLER2DRECT:
      case GLSLParser::ISAMPLER3D:
      case GLSLParser::ISAMPLERBUFFER:
      case GLSLParser::ISAMPLERCUBE:
      case GLSLParser::ISAMPLERCUBEARRAY:
      case GLSLParser::IVEC2:
      case GLSLParser::IVEC3:
      case GLSLParser::IVEC4:
      case GLSLParser::MAT2:
      case GLSLParser::MAT2X2:
      case GLSLParser::MAT2X3:
      case GLSLParser::MAT2X4:
      case GLSLParser::MAT3:
      case GLSLParser::MAT3X2:
      case GLSLParser::MAT3X3:
      case GLSLParser::MAT3X4:
      case GLSLParser::MAT4:
      case GLSLParser::MAT4X2:
      case GLSLParser::MAT4X3:
      case GLSLParser::MAT4X4:
      case GLSLParser::SAMPLER1D:
      case GLSLParser::SAMPLER1DARRAY:
      case GLSLParser::SAMPLER1DARRAYSHADOW:
      case GLSLParser::SAMPLER1DSHADOW:
      case GLSLParser::SAMPLER2D:
      case GLSLParser::SAMPLER2DARRAY:
      case GLSLParser::SAMPLER2DARRAYSHADOW:
      case GLSLParser::SAMPLER2DMS:
      case GLSLParser::SAMPLER2DMSARRAY:
      case GLSLParser::SAMPLER2DRECT:
      case GLSLParser::SAMPLER2DRECTSHADOW:
      case GLSLParser::SAMPLER2DSHADOW:
      case GLSLParser::SAMPLER3D:
      case GLSLParser::SAMPLERBUFFER:
      case GLSLParser::SAMPLERCUBE:
      case GLSLParser::SAMPLERCUBEARRAY:
      case GLSLParser::SAMPLERCUBEARRAYSHADOW:
      case GLSLParser::SAMPLERCUBESHADOW:
      case GLSLParser::STRUCT:
      case GLSLParser::TRUE:
      case GLSLParser::UIMAGE1D:
      case GLSLParser::UIMAGE1DARRAY:
      case GLSLParser::UIMAGE2D:
      case GLSLParser::UIMAGE2DARRAY:
      case GLSLParser::UIMAGE2DMS:
      case GLSLParser::UIMAGE2DMSARRAY:
      case GLSLParser::UIMAGE2DRECT:
      case GLSLParser::UIMAGE3D:
      case GLSLParser::UIMAGEBUFFER:
      case GLSLParser::UIMAGECUBE:
      case GLSLParser::UIMAGECUBEARRAY:
      case GLSLParser::UINT:
      case GLSLParser::USAMPLER1D:
      case GLSLParser::USAMPLER1DARRAY:
      case GLSLParser::USAMPLER2D:
      case GLSLParser::USAMPLER2DARRAY:
      case GLSLParser::USAMPLER2DMS:
      case GLSLParser::USAMPLER2DMSARRAY:
      case GLSLParser::USAMPLER2DRECT:
      case GLSLParser::USAMPLER3D:
      case GLSLParser::USAMPLERBUFFER:
      case GLSLParser::USAMPLERCUBE:
      case GLSLParser::USAMPLERCUBEARRAY:
      case GLSLParser::UVEC2:
      case GLSLParser::UVEC3:
      case GLSLParser::UVEC4:
      case GLSLParser::VEC2:
      case GLSLParser::VEC3:
      case GLSLParser::VEC4:
      case GLSLParser::VOID:
      case GLSLParser::BANG:
      case GLSLParser::DASH:
      case GLSLParser::DEC_OP:
      case GLSLParser::INC_OP:
      case GLSLParser::LEFT_PAREN:
      case GLSLParser::PLUS:
      case GLSLParser::TILDE:
      case GLSLParser::DOUBLECONSTANT:
      case GLSLParser::FLOATCONSTANT:
      case GLSLParser::INTCONSTANT:
      case GLSLParser::UINTCONSTANT:
      case GLSLParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 2);
        setState(710);
        expression(0);
        setState(711);
        match(GLSLParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Selection_statementContext ------------------------------------------------------------------

GLSLParser::Selection_statementContext::Selection_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Selection_statementContext::IF() {
  return getToken(GLSLParser::IF, 0);
}

tree::TerminalNode* GLSLParser::Selection_statementContext::LEFT_PAREN() {
  return getToken(GLSLParser::LEFT_PAREN, 0);
}

GLSLParser::ExpressionContext* GLSLParser::Selection_statementContext::expression() {
  return getRuleContext<GLSLParser::ExpressionContext>(0);
}

tree::TerminalNode* GLSLParser::Selection_statementContext::RIGHT_PAREN() {
  return getToken(GLSLParser::RIGHT_PAREN, 0);
}

GLSLParser::Selection_rest_statementContext* GLSLParser::Selection_statementContext::selection_rest_statement() {
  return getRuleContext<GLSLParser::Selection_rest_statementContext>(0);
}


size_t GLSLParser::Selection_statementContext::getRuleIndex() const {
  return GLSLParser::RuleSelection_statement;
}

void GLSLParser::Selection_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelection_statement(this);
}

void GLSLParser::Selection_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelection_statement(this);
}

GLSLParser::Selection_statementContext* GLSLParser::selection_statement() {
  Selection_statementContext *_localctx = _tracker.createInstance<Selection_statementContext>(_ctx, getState());
  enterRule(_localctx, 116, GLSLParser::RuleSelection_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(715);
    match(GLSLParser::IF);
    setState(716);
    match(GLSLParser::LEFT_PAREN);
    setState(717);
    expression(0);
    setState(718);
    match(GLSLParser::RIGHT_PAREN);
    setState(719);
    selection_rest_statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Selection_rest_statementContext ------------------------------------------------------------------

GLSLParser::Selection_rest_statementContext::Selection_rest_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<GLSLParser::StatementContext *> GLSLParser::Selection_rest_statementContext::statement() {
  return getRuleContexts<GLSLParser::StatementContext>();
}

GLSLParser::StatementContext* GLSLParser::Selection_rest_statementContext::statement(size_t i) {
  return getRuleContext<GLSLParser::StatementContext>(i);
}

tree::TerminalNode* GLSLParser::Selection_rest_statementContext::ELSE() {
  return getToken(GLSLParser::ELSE, 0);
}


size_t GLSLParser::Selection_rest_statementContext::getRuleIndex() const {
  return GLSLParser::RuleSelection_rest_statement;
}

void GLSLParser::Selection_rest_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelection_rest_statement(this);
}

void GLSLParser::Selection_rest_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelection_rest_statement(this);
}

GLSLParser::Selection_rest_statementContext* GLSLParser::selection_rest_statement() {
  Selection_rest_statementContext *_localctx = _tracker.createInstance<Selection_rest_statementContext>(_ctx, getState());
  enterRule(_localctx, 118, GLSLParser::RuleSelection_rest_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(721);
    statement();
    setState(724);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
    case 1: {
      setState(722);
      match(GLSLParser::ELSE);
      setState(723);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionContext ------------------------------------------------------------------

GLSLParser::ConditionContext::ConditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::ExpressionContext* GLSLParser::ConditionContext::expression() {
  return getRuleContext<GLSLParser::ExpressionContext>(0);
}

GLSLParser::Fully_specified_typeContext* GLSLParser::ConditionContext::fully_specified_type() {
  return getRuleContext<GLSLParser::Fully_specified_typeContext>(0);
}

tree::TerminalNode* GLSLParser::ConditionContext::IDENTIFIER() {
  return getToken(GLSLParser::IDENTIFIER, 0);
}

tree::TerminalNode* GLSLParser::ConditionContext::EQUAL() {
  return getToken(GLSLParser::EQUAL, 0);
}

GLSLParser::InitializerContext* GLSLParser::ConditionContext::initializer() {
  return getRuleContext<GLSLParser::InitializerContext>(0);
}


size_t GLSLParser::ConditionContext::getRuleIndex() const {
  return GLSLParser::RuleCondition;
}

void GLSLParser::ConditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCondition(this);
}

void GLSLParser::ConditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCondition(this);
}

GLSLParser::ConditionContext* GLSLParser::condition() {
  ConditionContext *_localctx = _tracker.createInstance<ConditionContext>(_ctx, getState());
  enterRule(_localctx, 120, GLSLParser::RuleCondition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(732);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(726);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(727);
      fully_specified_type();
      setState(728);
      match(GLSLParser::IDENTIFIER);
      setState(729);
      match(GLSLParser::EQUAL);
      setState(730);
      initializer();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_statementContext ------------------------------------------------------------------

GLSLParser::Switch_statementContext::Switch_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Switch_statementContext::SWITCH() {
  return getToken(GLSLParser::SWITCH, 0);
}

tree::TerminalNode* GLSLParser::Switch_statementContext::LEFT_PAREN() {
  return getToken(GLSLParser::LEFT_PAREN, 0);
}

GLSLParser::ExpressionContext* GLSLParser::Switch_statementContext::expression() {
  return getRuleContext<GLSLParser::ExpressionContext>(0);
}

tree::TerminalNode* GLSLParser::Switch_statementContext::RIGHT_PAREN() {
  return getToken(GLSLParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* GLSLParser::Switch_statementContext::LEFT_BRACE() {
  return getToken(GLSLParser::LEFT_BRACE, 0);
}

tree::TerminalNode* GLSLParser::Switch_statementContext::RIGHT_BRACE() {
  return getToken(GLSLParser::RIGHT_BRACE, 0);
}

GLSLParser::Statement_listContext* GLSLParser::Switch_statementContext::statement_list() {
  return getRuleContext<GLSLParser::Statement_listContext>(0);
}


size_t GLSLParser::Switch_statementContext::getRuleIndex() const {
  return GLSLParser::RuleSwitch_statement;
}

void GLSLParser::Switch_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_statement(this);
}

void GLSLParser::Switch_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_statement(this);
}

GLSLParser::Switch_statementContext* GLSLParser::switch_statement() {
  Switch_statementContext *_localctx = _tracker.createInstance<Switch_statementContext>(_ctx, getState());
  enterRule(_localctx, 122, GLSLParser::RuleSwitch_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(734);
    match(GLSLParser::SWITCH);
    setState(735);
    match(GLSLParser::LEFT_PAREN);
    setState(736);
    expression(0);
    setState(737);
    match(GLSLParser::RIGHT_PAREN);
    setState(738);
    match(GLSLParser::LEFT_BRACE);
    setState(740);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -8589934594) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -9007199321841665) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 4503599493205759) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & 2171300179101648895) != 0) || _la == GLSLParser::IDENTIFIER) {
      setState(739);
      statement_list();
    }
    setState(742);
    match(GLSLParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_labelContext ------------------------------------------------------------------

GLSLParser::Case_labelContext::Case_labelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Case_labelContext::CASE() {
  return getToken(GLSLParser::CASE, 0);
}

GLSLParser::ExpressionContext* GLSLParser::Case_labelContext::expression() {
  return getRuleContext<GLSLParser::ExpressionContext>(0);
}

tree::TerminalNode* GLSLParser::Case_labelContext::COLON() {
  return getToken(GLSLParser::COLON, 0);
}

tree::TerminalNode* GLSLParser::Case_labelContext::DEFAULT() {
  return getToken(GLSLParser::DEFAULT, 0);
}


size_t GLSLParser::Case_labelContext::getRuleIndex() const {
  return GLSLParser::RuleCase_label;
}

void GLSLParser::Case_labelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_label(this);
}

void GLSLParser::Case_labelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_label(this);
}

GLSLParser::Case_labelContext* GLSLParser::case_label() {
  Case_labelContext *_localctx = _tracker.createInstance<Case_labelContext>(_ctx, getState());
  enterRule(_localctx, 124, GLSLParser::RuleCase_label);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(750);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GLSLParser::CASE: {
        enterOuterAlt(_localctx, 1);
        setState(744);
        match(GLSLParser::CASE);
        setState(745);
        expression(0);
        setState(746);
        match(GLSLParser::COLON);
        break;
      }

      case GLSLParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(748);
        match(GLSLParser::DEFAULT);
        setState(749);
        match(GLSLParser::COLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Iteration_statementContext ------------------------------------------------------------------

GLSLParser::Iteration_statementContext::Iteration_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Iteration_statementContext::WHILE() {
  return getToken(GLSLParser::WHILE, 0);
}

tree::TerminalNode* GLSLParser::Iteration_statementContext::LEFT_PAREN() {
  return getToken(GLSLParser::LEFT_PAREN, 0);
}

GLSLParser::ConditionContext* GLSLParser::Iteration_statementContext::condition() {
  return getRuleContext<GLSLParser::ConditionContext>(0);
}

tree::TerminalNode* GLSLParser::Iteration_statementContext::RIGHT_PAREN() {
  return getToken(GLSLParser::RIGHT_PAREN, 0);
}

GLSLParser::Statement_no_new_scopeContext* GLSLParser::Iteration_statementContext::statement_no_new_scope() {
  return getRuleContext<GLSLParser::Statement_no_new_scopeContext>(0);
}

tree::TerminalNode* GLSLParser::Iteration_statementContext::DO() {
  return getToken(GLSLParser::DO, 0);
}

GLSLParser::StatementContext* GLSLParser::Iteration_statementContext::statement() {
  return getRuleContext<GLSLParser::StatementContext>(0);
}

GLSLParser::ExpressionContext* GLSLParser::Iteration_statementContext::expression() {
  return getRuleContext<GLSLParser::ExpressionContext>(0);
}

tree::TerminalNode* GLSLParser::Iteration_statementContext::SEMICOLON() {
  return getToken(GLSLParser::SEMICOLON, 0);
}

tree::TerminalNode* GLSLParser::Iteration_statementContext::FOR() {
  return getToken(GLSLParser::FOR, 0);
}

GLSLParser::For_init_statementContext* GLSLParser::Iteration_statementContext::for_init_statement() {
  return getRuleContext<GLSLParser::For_init_statementContext>(0);
}

GLSLParser::For_rest_statementContext* GLSLParser::Iteration_statementContext::for_rest_statement() {
  return getRuleContext<GLSLParser::For_rest_statementContext>(0);
}


size_t GLSLParser::Iteration_statementContext::getRuleIndex() const {
  return GLSLParser::RuleIteration_statement;
}

void GLSLParser::Iteration_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIteration_statement(this);
}

void GLSLParser::Iteration_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIteration_statement(this);
}

GLSLParser::Iteration_statementContext* GLSLParser::iteration_statement() {
  Iteration_statementContext *_localctx = _tracker.createInstance<Iteration_statementContext>(_ctx, getState());
  enterRule(_localctx, 126, GLSLParser::RuleIteration_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(773);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GLSLParser::WHILE: {
        enterOuterAlt(_localctx, 1);
        setState(752);
        match(GLSLParser::WHILE);
        setState(753);
        match(GLSLParser::LEFT_PAREN);
        setState(754);
        condition();
        setState(755);
        match(GLSLParser::RIGHT_PAREN);
        setState(756);
        statement_no_new_scope();
        break;
      }

      case GLSLParser::DO: {
        enterOuterAlt(_localctx, 2);
        setState(758);
        match(GLSLParser::DO);
        setState(759);
        statement();
        setState(760);
        match(GLSLParser::WHILE);
        setState(761);
        match(GLSLParser::LEFT_PAREN);
        setState(762);
        expression(0);
        setState(763);
        match(GLSLParser::RIGHT_PAREN);
        setState(764);
        match(GLSLParser::SEMICOLON);
        break;
      }

      case GLSLParser::FOR: {
        enterOuterAlt(_localctx, 3);
        setState(766);
        match(GLSLParser::FOR);
        setState(767);
        match(GLSLParser::LEFT_PAREN);
        setState(768);
        for_init_statement();
        setState(769);
        for_rest_statement();
        setState(770);
        match(GLSLParser::RIGHT_PAREN);
        setState(771);
        statement_no_new_scope();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_init_statementContext ------------------------------------------------------------------

GLSLParser::For_init_statementContext::For_init_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Expression_statementContext* GLSLParser::For_init_statementContext::expression_statement() {
  return getRuleContext<GLSLParser::Expression_statementContext>(0);
}

GLSLParser::Declaration_statementContext* GLSLParser::For_init_statementContext::declaration_statement() {
  return getRuleContext<GLSLParser::Declaration_statementContext>(0);
}


size_t GLSLParser::For_init_statementContext::getRuleIndex() const {
  return GLSLParser::RuleFor_init_statement;
}

void GLSLParser::For_init_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFor_init_statement(this);
}

void GLSLParser::For_init_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFor_init_statement(this);
}

GLSLParser::For_init_statementContext* GLSLParser::for_init_statement() {
  For_init_statementContext *_localctx = _tracker.createInstance<For_init_statementContext>(_ctx, getState());
  enterRule(_localctx, 128, GLSLParser::RuleFor_init_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(777);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(775);
      expression_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(776);
      declaration_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_rest_statementContext ------------------------------------------------------------------

GLSLParser::For_rest_statementContext::For_rest_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::For_rest_statementContext::SEMICOLON() {
  return getToken(GLSLParser::SEMICOLON, 0);
}

GLSLParser::ConditionContext* GLSLParser::For_rest_statementContext::condition() {
  return getRuleContext<GLSLParser::ConditionContext>(0);
}

GLSLParser::ExpressionContext* GLSLParser::For_rest_statementContext::expression() {
  return getRuleContext<GLSLParser::ExpressionContext>(0);
}


size_t GLSLParser::For_rest_statementContext::getRuleIndex() const {
  return GLSLParser::RuleFor_rest_statement;
}

void GLSLParser::For_rest_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFor_rest_statement(this);
}

void GLSLParser::For_rest_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFor_rest_statement(this);
}

GLSLParser::For_rest_statementContext* GLSLParser::for_rest_statement() {
  For_rest_statementContext *_localctx = _tracker.createInstance<For_rest_statementContext>(_ctx, getState());
  enterRule(_localctx, 130, GLSLParser::RuleFor_rest_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(780);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -696053195282) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -11540474112237569) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 4503599493172991) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & 2170737228074485247) != 0) || _la == GLSLParser::IDENTIFIER) {
      setState(779);
      condition();
    }
    setState(782);
    match(GLSLParser::SEMICOLON);
    setState(784);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 1) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1)) & -6917529530286505755) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & -4501401023543297) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 130)) & -9222246411859393985) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 194)) & -8138003422817533829) != 0)) {
      setState(783);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Jump_statementContext ------------------------------------------------------------------

GLSLParser::Jump_statementContext::Jump_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* GLSLParser::Jump_statementContext::CONTINUE() {
  return getToken(GLSLParser::CONTINUE, 0);
}

tree::TerminalNode* GLSLParser::Jump_statementContext::SEMICOLON() {
  return getToken(GLSLParser::SEMICOLON, 0);
}

tree::TerminalNode* GLSLParser::Jump_statementContext::BREAK() {
  return getToken(GLSLParser::BREAK, 0);
}

tree::TerminalNode* GLSLParser::Jump_statementContext::RETURN() {
  return getToken(GLSLParser::RETURN, 0);
}

GLSLParser::ExpressionContext* GLSLParser::Jump_statementContext::expression() {
  return getRuleContext<GLSLParser::ExpressionContext>(0);
}

tree::TerminalNode* GLSLParser::Jump_statementContext::DISCARD() {
  return getToken(GLSLParser::DISCARD, 0);
}


size_t GLSLParser::Jump_statementContext::getRuleIndex() const {
  return GLSLParser::RuleJump_statement;
}

void GLSLParser::Jump_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJump_statement(this);
}

void GLSLParser::Jump_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJump_statement(this);
}

GLSLParser::Jump_statementContext* GLSLParser::jump_statement() {
  Jump_statementContext *_localctx = _tracker.createInstance<Jump_statementContext>(_ctx, getState());
  enterRule(_localctx, 132, GLSLParser::RuleJump_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(797);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case GLSLParser::CONTINUE: {
        enterOuterAlt(_localctx, 1);
        setState(786);
        match(GLSLParser::CONTINUE);
        setState(787);
        match(GLSLParser::SEMICOLON);
        break;
      }

      case GLSLParser::BREAK: {
        enterOuterAlt(_localctx, 2);
        setState(788);
        match(GLSLParser::BREAK);
        setState(789);
        match(GLSLParser::SEMICOLON);
        break;
      }

      case GLSLParser::RETURN: {
        enterOuterAlt(_localctx, 3);
        setState(790);
        match(GLSLParser::RETURN);
        setState(792);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 1) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1)) & -6917529530286505755) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 66)) & -4501401023543297) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 130)) & -9222246411859393985) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 194)) & -8138003422817533829) != 0)) {
          setState(791);
          expression(0);
        }
        setState(794);
        match(GLSLParser::SEMICOLON);
        break;
      }

      case GLSLParser::DISCARD: {
        enterOuterAlt(_localctx, 4);
        setState(795);
        match(GLSLParser::DISCARD);
        setState(796);
        match(GLSLParser::SEMICOLON);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- External_declarationContext ------------------------------------------------------------------

GLSLParser::External_declarationContext::External_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Function_definitionContext* GLSLParser::External_declarationContext::function_definition() {
  return getRuleContext<GLSLParser::Function_definitionContext>(0);
}

GLSLParser::DeclarationContext* GLSLParser::External_declarationContext::declaration() {
  return getRuleContext<GLSLParser::DeclarationContext>(0);
}

tree::TerminalNode* GLSLParser::External_declarationContext::SEMICOLON() {
  return getToken(GLSLParser::SEMICOLON, 0);
}


size_t GLSLParser::External_declarationContext::getRuleIndex() const {
  return GLSLParser::RuleExternal_declaration;
}

void GLSLParser::External_declarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExternal_declaration(this);
}

void GLSLParser::External_declarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExternal_declaration(this);
}

GLSLParser::External_declarationContext* GLSLParser::external_declaration() {
  External_declarationContext *_localctx = _tracker.createInstance<External_declarationContext>(_ctx, getState());
  enterRule(_localctx, 134, GLSLParser::RuleExternal_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(802);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(799);
      function_definition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(800);
      declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(801);
      match(GLSLParser::SEMICOLON);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_definitionContext ------------------------------------------------------------------

GLSLParser::Function_definitionContext::Function_definitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

GLSLParser::Function_prototypeContext* GLSLParser::Function_definitionContext::function_prototype() {
  return getRuleContext<GLSLParser::Function_prototypeContext>(0);
}

GLSLParser::Compound_statement_no_new_scopeContext* GLSLParser::Function_definitionContext::compound_statement_no_new_scope() {
  return getRuleContext<GLSLParser::Compound_statement_no_new_scopeContext>(0);
}


size_t GLSLParser::Function_definitionContext::getRuleIndex() const {
  return GLSLParser::RuleFunction_definition;
}

void GLSLParser::Function_definitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_definition(this);
}

void GLSLParser::Function_definitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<GLSLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_definition(this);
}

GLSLParser::Function_definitionContext* GLSLParser::function_definition() {
  Function_definitionContext *_localctx = _tracker.createInstance<Function_definitionContext>(_ctx, getState());
  enterRule(_localctx, 136, GLSLParser::RuleFunction_definition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(804);
    function_prototype();
    setState(805);
    compound_statement_no_new_scope();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool GLSLParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 3: return postfix_expressionSempred(antlrcpp::downCast<Postfix_expressionContext *>(context), predicateIndex);
    case 13: return binary_expressionSempred(antlrcpp::downCast<Binary_expressionContext *>(context), predicateIndex);
    case 14: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool GLSLParser::postfix_expressionSempred(Postfix_expressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 6);
    case 1: return precpred(_ctx, 5);
    case 2: return precpred(_ctx, 3);
    case 3: return precpred(_ctx, 2);
    case 4: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool GLSLParser::binary_expressionSempred(Binary_expressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 5: return precpred(_ctx, 11);
    case 6: return precpred(_ctx, 10);
    case 7: return precpred(_ctx, 9);
    case 8: return precpred(_ctx, 8);
    case 9: return precpred(_ctx, 7);
    case 10: return precpred(_ctx, 6);
    case 11: return precpred(_ctx, 5);
    case 12: return precpred(_ctx, 4);
    case 13: return precpred(_ctx, 3);
    case 14: return precpred(_ctx, 2);
    case 15: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool GLSLParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 16: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

void GLSLParser::initialize() {
  ::antlr4::internal::call_once(glslparserParserOnceFlag, glslparserParserInitialize);
}
